{"meta":{"title":"何相昆","subtitle":"","description":"","author":"hexiangkun","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-09-17T02:39:49.988Z","updated":"2022-09-17T02:39:49.988Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-09-17T02:39:49.989Z","updated":"2022-09-17T02:39:49.989Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2022-09-17T02:39:49.990Z","updated":"2022-09-17T02:39:49.990Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-09-17T02:39:49.990Z","updated":"2022-09-17T02:39:49.990Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-09-17T02:39:49.990Z","updated":"2022-09-17T02:39:49.990Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-17T02:39:49.992Z","updated":"2022-09-17T02:39:49.992Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-09-17T02:39:49.990Z","updated":"2022-09-17T02:39:49.990Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"C++基础","slug":"C++基础","date":"2023-04-09T04:44:09.000Z","updated":"2023-04-09T04:45:57.947Z","comments":true,"path":"2023/04/09/C++基础/","link":"","permalink":"http://example.com/2023/04/09/C++%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 语言基础 (C&#x2F;C++)指针和引用的区别 指针是一个新的变量，指向另一个变量的地址，可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变；而引用是一个别名，对引用的操作就是对变量的本身进行操作 指针可以有多级，引用只有一级 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小 指针可以为空，引用不可以。 在函数参数传递的时候，什么时候使用指针，什么时候使用引用？ 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式 堆和栈有什么区别 从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。 堆空间因为会有频繁的分配释放操作，会产生内存碎片 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小 堆快一点还是栈快一点？（字节提前批一面） 栈快一点。 因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。 堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。 new和delete是如何实现的，new 与 malloc的异同处 malloc和free是库函数，new和delete是C++的操作符 new在动态分配内存的时候可以初始化对象，调用其构造函数（malloc&#x2F;构造函数），delete在释放内存时调用对象的析构函数（析构函数&#x2F;free）。 new和malloc都会分配空间，但是new会自己计算需要的空间，malloc需要给定空间大小，而且new只需要对象名。 new和delete可以重载，malloc和free不行。new可以调用malloc来实现，但是malloc不能调用new来实现。 new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。 既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？ https://blog.csdn.net/leikun153/article/details/80612130 malloc&#x2F;free和new&#x2F;delete都是用来申请内存和回收内存的。 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free。 malloc底层实现 malloc小于128K的内存，使用brk分配 将_edata往高地址推（只分配虚拟空间，不对应物理内存（因此没有初始化），第一次读写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后简历虚拟地址和物理地址之间的映射关系） malloc大于128k的内存，使用mmap分配 利用mmap系统调用，从堆和栈的中间分配一块虚拟内存 C和C++的区别包括但不限于： C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。 C和C++内存管理的方法不一样，C使用malloc&#x2F;free，C++除此之外还用new&#x2F;delete C++中还有函数重载和引用等概念，C中没有 delete和delete[]的区别 delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数 用new分配的内存用delete释放，用new[]分配的内存用delete[]释放 C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）包括但不限于： C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。 C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法 C++有指针，Java没有指针，只有引用 JAVA和C++都有构造函数，但是C++有析构函数但是Java没有 C++和python的区别包括但不限于： python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。 python使用缩进来区分不同的代码块，C++使用花括号来区分 C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等 python的库函数比C++的多，调用起来很方便 Struct和class的区别 使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的 struct的继承默认是public继承，而class的继承默认是private继承 class可以用作定义模板参数，而struct不能 define 和const的联系与区别 联系：它们都是定义常量的一种方法。 区别： define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。 define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。 define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。 const可以定义函数而define不可以。 （12） 在C++中const的用法（定义，用途） const修饰类的成员变量时，表示常量不能被修改 const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer） 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 野指针野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。 volatile 关键字 volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。 用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错 register关键字 register关键字请求“编译器”将局部变量存储于寄存器中 static关键字static的意思是静态的，可以用来修饰变量，函数和类成员。 变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。 函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。 类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。 【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。 注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。 const关键字123456789const int a; // 代表一个常整形数int const b; // 代表一个常整形数const int *c;// c是一个指向常整形数的指针(所指向的内存数据不能被修改，但是本身可以修改)int * const d;// d是常指针（指针变量不能被修改，但是它所指向内存空间可以被修改）const int * const e ;// e是一个指向常整形的常指针（指针和它所指向的内存空间，均不能被修改） mutable关键字 在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。 我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。 extern Cextern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 explicit关键字 普通构造函数能够被隐式调用。而explicit构造函数只能被显式调用。 explicit构造函数是用来防止隐式转换的。 指定这个构造器只能被明确的调用&#x2F;使用， 不能作为类型转换操作符被隐含的使用。 final关键字 将类标记为final，意味着继承该类会导致编译错误 允许将虚函数标记为final，意味着子类无法重写该方法。 C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等 C++ STL从广义来讲包括了三类：算法，容器和迭代器。 算法包括排序，复制等常用算法，以及不同容器特定的算法。 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。 迭代器就是在不暴露容器内部结构的情况下对容器的遍历。 allocator内存分配器原理 allocator分配器，其本质上也是调用了malloc函数。 对于大于128B的空间直接就是malloc()和free() 对于小于128B的请求采用了次级分配器；SGI维护一个内存池来处理这些请求，以保证效率。它会将请求的字节数n圆整到8的倍数，比如如果请求的是14B的空间，其实获得的是16B；从这也可以得出SGI一共有16个链表需要维护，每个链表对应一个分配级别，对应的内存块大小分别是：8、16、24、…、128。 Arrayarray即数组，其大小固定，所有元素严格按照内存地址线性排列，array并不维护元素之外的任何多余数据，没有size这个变量 Deque deque是一种能够在头尾两端分别做元素的插入和删除操作的双端队列容器。 deque和vector的区别： deque允许常数项时间对头端元素进行插入和删除操作。vector头部的插入效率低，数据量越大，效率越低 deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并连接起来。 vector访问元素的速度会比deque快。 deque实现原理 从逻辑上看，deque容器是连续空间，但是deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量空间，串接在deque的头端或者尾端。 为了管理这些连续空间，deque容器用数组存储着各个连续空间的首地址。 deque可以随机存取元素（支持索引值直接存取，用[]或者at()方法） Heap 快排和堆排序的比较 堆排序访问数据的方式没有快速排序友好。对于快速排序来说，数据是顺序访问的，对于堆排序来说，数据是跳着访问的。 对于同样的数据，在排序过程中，堆排序算法的数据交换次数多于快速排序。 堆实际上使用数据或者vector表现出来的一颗具有特殊结构的完全二叉树。 大顶堆：每个非叶子节点元素的值均不小于其左右孩子节点。 List list是一个双向链表容器，可以高效地插入和删除元素，支持双向遍历。 list元素节点不要求在一段连续内存中，不能随机存取元素 和其它顺序容器相比，list最大优势在于支持在任意位置插入、删除、移动元素 list主要缺点是不支持元素的随机访问；对内存的使用效率并不高，一方面因为地址不连续，另一方面因为需要额外的保存关联信息 forward_list 顺序容器：支持在任意位置插入和删除元素的容器，单链表 forward_list占用内存空间更小，且插入和删除效率高于list，只能单向遍历 priority_queue priority_queue又称为优先队列，底层用堆来实现。在优先队列中，队首元素一定是优先级最高的一个。 priority_queue的的核心特点在于其严格弱序特性，即priority_queue保证容器第一个元素始终是所有元素最大的 priority_queue的底层容器必须支持随机访问（deque、vector）默认使用vector queue queue是队列容器（容器适配器deque、list），是一种“先进先出”FIFO的容器。（一端插入一端删除） 所谓容器适配器，指它本身只是一个封装层，必须依赖指定的底层容器才能实现具体功能 queue是一种类型的容器的适配器，其是使用特定容器类封装到对象内部，作为其底层容器。（list和deque满足要求） Stack 容器适配器（vector、list、deque）默认使用deque 后进先出，不允许遍历 Map map是标准的关联式容器，一个map是一个键值对序列，即（key，value）。它提供基于key的快速检索能力。 所谓关联容器，是指对所有元素的检索都是通过元素的key进行的，而非元素地址 map中key值是唯一的。map主要用于一对一映射。map内部自建一颗红黑树，这颗树具有对数据自动排序的功能。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入和删除操作上比vector快。 map支持[]操作符，map[key]&#x3D;value Multimap multimap和map的区别：map支持唯一键值，每个键只能出现一次；而multimap相同键可以出现多次。 set set是一个关联式容器，set是一个集合容器，其所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素的插入过程是按排序规则插入，不能指定插入位置。 set采用红黑树的数据结构实现。在插入和删除操作上要比vector快。 set不可以直接存取元素。 不可以直接修改set或者multiset容器中的元素值，因为该容器是自动排列的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。 multiset multiset与set区别：set支持唯一键值，每个元素只能出现一次；而multiset中同一值可以出现多次。 unordered_set unordered_set元素都是不可变的，可以删除和插入，元素不允许重复 unordered_set元素是无序的，不能按照大小排序 unordered_multiset 元素允许重复 unordered_map 关联容器，&lt;key,value&gt;作为元素进行存储 底层数据结构哈希表，不支持排序，使用迭代器进行范围访问时效率低；但是直接访问元素的效率更快 unordered_multimap unordered_multimap是对unordered_map的拓展，唯一区别在于unordered_map允许不同元素的key相同，底层数据结构都是一样的 tuple tuple 叫作元组，它可以把一组类型相同或不同的元素组合到一起，且元素的数量不限 pair 可以看作是把 tuple 的 size 限制为 2 的一个特例 为何map和set的插入和删除效率比其他序列容器高？ 对于关联容器来说，不需要做内存拷贝和内存移动。 因为插入的时候，只需要吧节点的指针指向新的节点就可以了。删除的时候，稍作变换后把指向删除节点的指针指向其他节点。只有指针变换，不存在内存移动。 map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。 set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。 map支持下标操作，set不支持下标操作。 为何map和set每次insert之后，以前保存的iterator不会失效？ iterator相当于指向节点的指针，内存没有变，指向内存的指针就不会失效。（除被删除的元素之外）。 相对于vector来说，每一次插入和删除，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。当使用push_back时，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请更大的内存，复制已有的数据元素到新内存，最后把需要插入的元素放到最后，那么以前内存指针自然就不可用了。 当数据元素增多时，set的插入和搜素速度变化如何？在set中查找使用二分查找。 map和set的区别 map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。 set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。**其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡。 map支持下标操作，set不支持下标操作。 stack stack是堆栈容器，是一种“先进后出”的容器。 stack是简单地装饰deque容器而成为另外的一种容器。 Vector vector和数组的区别 数组：分配的是静态空间，一般分配了就不可以改变。 vector：分配的是动态空间。vector随着元素的加入，空间自动拓展。 vector机制：预留一部分空间，而且预留空间大小是按一定比率增长的，如果空间不够用，重新分配空间，然后将原有元素移动到新空间，同时预留新空间。 vector释放内存 通过swap函数实现内存释放思想。 1vector&lt;int&gt;(vec).swap(vec); vector(vec)临时对象拷贝构造函数拷贝了vec的size和元素，该部分的size和capacity都是7，然后该临时对象和vec交换，vec的size和capacity变成7，临时对象的size为7，capacity为16，然后被析构了。 string的底层实现string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。 string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。 set，map和vector的插入复杂度 set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。 unordered_set,unordered_map的插入复杂度是常数，最坏是O(N). vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝 STL源码中的hash表的实现STL中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。 unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。 解决哈希冲突的方式？ 线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。 二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。 双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。 开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。 建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。 STL中unordered_map和map的区别 unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现&#x3D;&#x3D;操作符。 map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。 STL中vector的实现STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。 在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。 vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。 push_back()函数调用过程中，如果当前vector的长度等于其容量，那么会导致扩容，容量变为之前的两倍。 在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。 push_back()函数是浅拷贝。 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。 C++中vector和list的区别 vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。 list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。 vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+&#x3D;”，“&lt;”等操作符。 list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+&#x3D;”、“&lt;”等 vector::iterator和list::iterator都重载了“++”运算符 总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;如果需要大量的插入和删除，而不关心随机存取，则应使用list。 vector会迭代器失效吗？什么情况下会迭代器失效？https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html 会 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效 当vector在插入的时候，end迭代器肯定会失效 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。 STL中的sort()算法是用什么实现的，stable_sort()呢STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。 https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html 会 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效 当vector在插入的时候，end迭代器肯定会失效 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。 C ++内存管理（热门问题）https://blog.csdn.net/qq_43152052/article/details/98889139 在C++中，内存分成5个区，他们分别是堆、栈、全局&#x2F;静态存储区和常量存储区和代码区。 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 全局&#x2F;静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。字符串常量，之所以称之为常量，因为它可一看作是一个没有命名的字符串且为常量，存放在静态数据区。 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。 代码区，存放程序的二进制代码 关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。 编译链接 预编译：预编译器处理如#define、#include等预编译指令，生成.i或.ii文件 编译：编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化、生成.s文件 汇编：汇编器把汇编码翻译成机器码，生成.o文件 链接：链接器进行地址和空间分配、符号决议、重定位，生成.out文件 内存泄露 概念：程序申请内存后，无法释放已申请的内存空间造成了内存泄露。失去了对该段的控制，因此造成了内存的浪费。 分类： 堆内存泄露 malloc、new从堆中分配的内存 系统资源泄露 主要指程序使用系统分配的资源如socket等没有使用相应的函数释放掉，导致系统内资源的浪费。 没有将基类的析构函数定义为虚函数 当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会调用，子类资源没有正确释放。 介绍面向对象的三大特性，并且举例说明每一个。面向对象的三大特性是：封装，继承和多态。 封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public； 继承使得子类可以复用父类的成员和方法，实现了代码重用； 多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。 计算下面几个类的大小：12345678class A &#123;&#125;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1; A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1; return 0;&#125; 空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。 空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。 1234567class A &#123; virtual Fun()&#123;&#125; &#125;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器); A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器); return 0;&#125; 因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节 1234567class A &#123; static int a; &#125;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1; A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1; return 0;&#125; 静态成员存放在静态存储区，不占用类的大小, 普通成员函数、构造函数、析构函数也不占用类大小 1234567class A &#123; int a; &#125;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4; A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4; return 0;&#125; 1234567class A &#123; static int a; int b; &#125;;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4; A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4; return 0;&#125; 静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节 继承子类的占用空间 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class A&#123;&#125;;class B&#123;&#125;;class C :public A&#123;&#125;;class D :public virtual B&#123;&#125;;class E :public A, public B&#123;&#125;;int main()&#123; A a; B b; C c; D d; E e; cout &lt;&lt; &quot;sizeof(a):&quot; &lt;&lt; sizeof(a) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(b):&quot; &lt;&lt; sizeof(b) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(c):&quot; &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(d):&quot; &lt;&lt; sizeof(d) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(e):&quot; &lt;&lt; sizeof(e) &lt;&lt; endl; return 0;&#125; 输出结果为： 123456sizeof(a):1sizeof(b):1sizeof(c):1sizeof(d):4sizeof(e):1 上面案例定义了一个空类A和B，类C继承了类A，类D继承了虚基类B，类E继承了类A和类B。这些类的对象所占的空间都是1Byte。由此可见，单一继承的空类空间也是 1，多重继承的空类空间还是1，但是虚继承涉及虚表（虚指针），所以sizeof(d)&#x3D;4。 C++中的重载和重写的区别： 重载（overload）是指函数名相同，参数列表（类型不同、数量不同）不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。 重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。 详见：https://blog.csdn.net/weixin_30379911/article/details/99497160 派生类的构造函数与析构函数调用顺序构造函数和析构函数的调用顺序是先构造的后析构，后构造的先析构。 构造函数的调用顺序规则如下所述： 1） 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。 2） 成员类对象构造函数。如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。 3） 派生类构造函数。 而析构函数的调用顺序与构造函数的调用顺序正好相反，将上面3点内容中的顺序反过来用就可以了，即：首先调用派生类的析构函数；其次再调用成员类对象的析构函数；最后调用基类的析构函数。析构函数在下面3种情况时被调用： 1）对象生命周期结束被销毁时（一般类成员的指针变量与引用都不自动调用析构函数）。 2）delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时。 3）对象 i 是对象 o 的成员，o 的析构函数被调用时，对象 i 的析构函数也被调用。 virtual继承虚拟基类是为了解决多重继承而出现的。例如A继承了Y,Z。而Y,Z继承自X，因此A两次出现了类x中的变量和函数，可以将Y,Z定义为虚拟继承。而x则变成了虚拟继承的基类 class X{ }； class Y： public virtual X{ }； class Z： public virtual X{ }； class A ：public Y， public Z{ }； 多态的实现C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。 多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。 虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数. 该实验中有Base父类和Son子类，然后使用了多态，让父类指针指向子类。从结果可以看到： 父类指向子类后，如果调用子类中的虚函数，则调用的是子类虚函数； 如果调用和父类同名的非虚函数，那么还是使用父类的函数 父类不能调用子类自己定义的函数（例如func3），任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法。 C++虚函数表解析 https://www.cnblogs.com/findumars/p/6358207.html?utm_source=itdadao&amp;utm_medium=referral C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。 详见：C++虚函数表剖析 如果多重继承和多继承的话，子类的虚函数表长什么样子？多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：https://blog.csdn.net/qq_36359022/article/details/81870219 实现编译器处理虚函数表应该如何处理编译器处理虚函数的方法是：如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。详见：虚函数的作用及其底层实现机制 基类的析构函数一般写成虚函数的原因首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。 如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。 构造函数为什么一般不定义为虚函数1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等 2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了 构造函数或者析构函数中调用虚函数会怎样在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。 在析构函数中调用虚函数，此时调用的是子类的函数实现方式。 纯虚函数纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承 包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象 使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？ 成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下： 1234567class A&#123;int id;string name;FaceImage face;A(int&amp; inputID,string&amp; inputName,FaceImage&amp; inputFace):id(inputID),name(inputName),face(inputFace)&#123;&#125; // 成员初始化列表&#125;; 因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。另外，有三种情况是必须使用成员初始化列表进行初始化的： 常量成员的初始化，因为常量成员只能初始化不能赋值 引用类型 没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化 详见[C++ 初始化列表]( 静态绑定和动态绑定的介绍C++中的静态绑定和动态绑定 静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。 动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。 而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。 深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。 对象复用的了解，零拷贝的了解对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。 零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。 用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。 介绍C++所有的构造函数C++中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数 默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。 重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。 拷贝构造函数是在发生对象复制的时候调用的。 什么情况下会调用拷贝构造函数（三种情况） 对象以值传递的方式传入函数参数 如 void func(Dog dog)&#123;&#125;; 对象以值传递的方式从函数返回 如 Dog func()&#123; Dog d; return d;&#125; 对象需要通过另外一个对象进行初始化 详见：C++拷贝构造函数详解 结构体内存对齐方式和为什么要进行内存对齐？因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。 对齐规则： 第一个成员在与结构体变量偏移量为0的地址 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 对齐数&#x3D;编译器默认的一个对齐数 与 该成员大小的较小值。 linux 中默认为4 vs 中的默认值为8结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数） 内存泄露的定义，如何检测与避免？动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。 造成内存泄漏的几种原因： 1）类的构造函数和析构函数中new和delete没有配套 2）在释放对象数组时没有使用delete[]，使用了delete 3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露 4）没有正确的清楚嵌套的对象指针 避免方法： malloc&#x2F;free要配套 使用智能指针； 将基类的析构函数设为虚函数； C++的智能指针有哪些C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。 auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。 unique_ptr是一种对资源具有排他性拥有权的智能指针，不能赋值也不能拷贝，保证一个对象只有被一个unique_ptr指向。可以通过移动赋值或者移动拷贝这种方法来重新指定所指对象的所有权。 shared_ptr多个智能指针指向相同的对象，当这个对象所有的智能指针被销毁时就会自动进行回收。拷贝使得对象的引用计数加1，赋值使得原对象引用计数减1（内部使用计数机制进行维护） weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。 调试程序的方法 通过设置断点进行调试 打印log进行调试 打印中间结果进行调试 遇到coredump要怎么调试coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。 使用gdb命令对core文件进行调试 以下例子在Linux上编写一段代码并导致segment fault 并产生core文件 123mkdir coredumpTestvim coredumpTest.cpp 在编辑器内键入 12345678#include&lt;stdio.h&gt;int main()&#123; int i; scanf(&quot;%d&quot;,i);//正确的应该是&amp;i,这里使用i会导致segment fault printf(&quot;%d\\n&quot;,i); return 0;&#125; 编译 12g++ coredumpTest.cpp -g -o coredumpTest 运行 12./coredumpTest 使用gdb调试coredump 12gdb [可执行文件名] [core文件名] inline关键字说一下 和宏定义有什么区别inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。 1、内联函数在编译时展开，而宏在预编译时展开 2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 4、宏不是函数，而inline是函数 5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。 7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。 模板的用法与适用场景 实现原理用template &lt;typename T&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了 编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。 https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html) 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11） 自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作 nullptr：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的 lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125; thread类和mutex类 新的智能指针 unique_ptr和shared_ptr 更多详见：https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279 右值 区分左值和右值：能不能对表达式取地址 移动语义：将内存的所有权从一个对象转移到另外一个对象，高效的移动用来替换效率底下的复制，对象的移动语义需要实现移动构造函数和移动赋值运算符 完美转发：定义一个函数模板，该函数模板可以接收任意类型参数，然后将参数转发给其他目标函数，且保证目标函数接受的参数其类型与传递给模板函数的类型相同。 C++的调用惯例（简单一点C++函数调用的压栈过程）函数的调用过程： 1）从栈空间分配存储空间 2）从实参的存储空间复制值到形参栈空间 3）进行运算 形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。 数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。 当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。 C++的四种cast强制转换四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast static_cast ：用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。 特性与要点： 它没有运行时类型检查，所以是有安全隐患的。 在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。 static_cast不能转换const，volatile等属性 dynamic_cast：用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。dynamic_cast如果不能转换返回NULL。 const_cast：用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。 reinterpret_cast几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。 类型 作用 static_cast 静态类型转换 reinterpreter_cast 重新解释类型转换。 dynamic_cast 子类和父类之间的多态类型转换。 const_cast 去掉const属性转换 一个函数或者可执行文件的生成过程或者编译过程是怎样的预处理，编译，汇编，链接 预处理： 对预处理命令进行替换等预处理操作 编译：代码优化和生成汇编代码 汇编：将汇编代码转化为机器语言 链接：将目标文件彼此链接起来 定义和声明的区别 声明是告诉编译器变量的类型和名字，不会为变量分配空间 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次 typdef和define区别#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查 typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名 被free回收的内存是立即返还给操作系统吗？为什么https://blog.csdn.net/YMY_mine/article/details/81180168 不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。 引用作为函数参数以及返回值的好处对比值传递，引用传参的好处： 1）在函数内部可以对此参数进行修改 2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗） 如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。 用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。 但是有以下的限制： 1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁 2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak 3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 友元函数和友元类https://www.cnblogs.com/zhuguanhao/p/6286145.html 友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。 1）友元函数 有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class A&#123;public: friend void set_show(int x, A &amp;a); //该函数是友元函数的声明private: int data;&#125;;void set_show(int x, A &amp;a) //友元函数定义，为了访问类A中的成员&#123; a.data = x; cout &lt;&lt; a.data &lt;&lt; endl;&#125;int main(void)&#123; class A a; set_show(1, a); return 0;&#125; 一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。 2）友元类 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明 12345678910111213141516171819202122232425262728 #include &lt;iostream&gt;using namespace std;class A&#123;public: friend class C; //这是友元类的声明private: int data;&#125;;class C //友元类定义，为了访问类A中的成员&#123;public: void set_show(int x, A &amp;a) &#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;&#125;;int main(void)&#123; class A a; class C c; c.set_show(1, a); return 0;&#125; 使用友元类时注意： (1) 友元关系不能被继承。 (2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 (3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明 说一下volatile关键字的作用volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。 为什么C++没有实现垃圾回收？ 首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。 垃圾回收会使得C++不适合进行很多底层的操作。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Daliy_Calorie_App","slug":"Daliy-Calorie-App","date":"2022-10-25T12:34:09.000Z","updated":"2023-04-09T04:42:39.298Z","comments":true,"path":"2022/10/25/Daliy-Calorie-App/","link":"","permalink":"http://example.com/2022/10/25/Daliy-Calorie-App/","excerpt":"","text":"Document /* 标签选择器 */ h2 { font-family: \"微软雅黑\"; } p { font-family: \"楷体\"; font-size:20px; } b { font-family: \"楷体\"; font-size:20px; } li{ font-family: \"楷体\"; font-size:20px; } Title: Daliy Calorie App 1. Problem After the third scientific and technological revolution, the quality of life of modern people has improved rapidly, famine has left us, and few people are hungry. In recent years, more and more people have a strong demand for healthy living and body management, so we hope to make such an app to control people's calorie and nutrient intake, and provide corresponding diet plans and Athletic training program. 2. Users So our target demographic is more inclined to young people.Humans who have requirements for weight control and healthy living, or fitness people who need to gain muscle or lose fat. (1). Women: They usually focus on fat reduction, shaping and postpartum repair, and record and test their diet health through fitness apps; (2). Men: They usually lose weight and gain muscle; (3). Teenagers: They make scientific and reasonable sports plans to help themselves grow up healthily; (4). The elderly: They pay more attention to sports injury repair. 3. Task scenario (1). Having meals and want to control intake An obese person reduces his/her calorie intake through diet, so that his/her calorie intake is less than that required for daily basic metabolism. (2). Exercising and want find good plans Anyone who wants to have a better figure can achieve his desired figure by making a reasonable exercise plan. (3). Choosing foods with high protein and low fat Fitness professionals hope to increase their muscle circumference, calculate the daily intake of protein and fat, the minimum intake of carbohydrates, and formulate a reasonable vegetable diet. (4). Rational distribution of aerobic and anaerobic exercise For people who have reduced fat, it is necessary to increase the time of aerobic exercise and reduce the time of anaerobic exercise. For people with muscle enhancement, it is necessary to increase anaerobic exercise time and reduce aerobic exercise time. At the same time, ensure that strength training precedes aerobic exercise. (5). Planning for future exercising Anyone who wants to exercise should plan a future exercise plan to ensure that they are moving in the right direction. 4. Tasks (1). How to Calculate the daily calorie profit and loss daily food calorie intake - basal metabolism - exercise consumption = daily calorie gain and loss The daily food calorie and nutrient intake are captured by the in-app camera, and the category and weight of the food are identified by artificial intelligence. The calculation formula of rough measurement of basal metabolic rate is : Female basal metabolic rate=661+9.6×weight (kg)+1.72×height (cm)-4.7×age Male basal metabolic rate=67+13.73×weight (kg)+5×height (cm)-6.9×age Exercise consumption is calculated by the smart bracelet.Bring a sports bracelet (such as Xiaomi sports bracelet), bind the sports bracelet to the daily calorie app, and calculate the energy consumed by the daily walking steps and the exercise time of the corresponding exercise (the Xiaomi sports bracelet has been implement this function) (2). How to Calculate daily nutrient intake. Authorize the camera, put food on a custom-sized plate (do not stack food), take a photo, identify the category and weight of things through a pre-trained deep learning network, query the nutrients and calories per unit mass of food in the database, and calculate Calorie intake and nutrients. (3). How to Provide nutrition . According to the user's eating habits and fitness purpose, give a healthy eating plan (can be customized after payment). (4). How to provide training programs. According to the user's heart rate and exercise habits, remind the user that they should exercise or take a proper rest, and give a training plan in stages (can be customized after payment) (5). How to Help users achieve a healthy life. Daily popularize the nutritional content of healthy food, and call on users to consume more organic food to improve users' dietary sensitivity. 5. Team role Lin Tong: Detailed design He Xiangkun : Perfect the design & Publish to website","categories":[{"name":"HCI","slug":"HCI","permalink":"http://example.com/categories/HCI/"}],"tags":[{"name":"HCI","slug":"HCI","permalink":"http://example.com/tags/HCI/"}]},{"title":"Daliy_Calorie","slug":"Daliy-Calorie","date":"2022-09-18T02:58:12.000Z","updated":"2023-04-09T04:42:21.997Z","comments":true,"path":"2022/09/18/Daliy-Calorie/","link":"","permalink":"http://example.com/2022/09/18/Daliy-Calorie/","excerpt":"","text":"Document /* 标签选择器 */ h2 { font-family: \"微软雅黑\"; } p { font-family: \"楷体\"; font-size:20px; } b { font-family: \"楷体\"; font-size:20px; } li{ font-family: \"楷体\"; font-size:20px; } Daliy Calorie App 1. Background After the third scientific and technological revolution, the quality of life of modern people has improved rapidly, famine has left us, and few people are hungry. After the third scientific and technological revolution, the quality of life of modern people has improved rapidly, famine has left us, and few people are hungry. 1. Global graph of the number of obese women in 1975-20161 2. Global male obesity graph from 1975-20162 In recent years, more and more people have a strong demand for healthy living and body management, so we hope to make such an app to control people's calorie and nutrient intake, and provide corresponding diet plans and Athletic training program. 2. Application function (1). Calculate the daily calorie profit and loss and daily nutrient intake. (2). Control the user's weight. (3). Provide nutrition and training programs. (4). Help users achieve a healthy life. 3. Calculation formula (1). daily food calorie intake - basal metabolism - exercise consumption = daily calorie gain and loss (2). The daily food calorie and nutrient intake are captured by the in-app camera, and the category and weight of the food are identified by artificial intelligence. (3). The calculation formula of rough measurement of basal metabolic rate is : Female basal metabolic rate=661+9.6×weight (kg)+1.72×height (cm)-4.7×age Male basal metabolic rate=67+13.73×weight (kg)+5×height (cm)-6.9×age (4). Exercise consumption is calculated by the smart bracelet. 4. Target users Our target demographic is more inclined to young people.Humans who have requirements for weight control and healthy living, or fitness people who need to gain muscle or lose fat. 3. Age distribution of fitness people3 5. Team division of labor 5 for demand, 10 for design, 10 for development, 5 for testing, 5 for project, 5 for operation and maintenance, and 3 for overall management. 6. Design tasks and solutions to corresponding problems Calculate the daily food calorie and nutrient intake. Authorize the camera, put food on a custom-sized plate (do not stack food), take a photo, identify the category and weight of things through a pre-trained deep learning network, query the nutrients and calories per unit mass of food in the database, and calculate Calorie intake and nutrients. Calculate the basal metabolism of the human body. Due to the difference of each person's constitution and hormones, it is difficult to accurately measure the basal metabolic rate. We use the calculation formula of the basal metabolic rate: Female basal metabolic rate=661+9.6×weight (kg)+1.72×height (cm)-4.7×age Male basal metabolic rate=67+13.73×weight (kg)+5×height (cm)-6.9×age Calculate the exercise consumption. Bring a sports bracelet (such as Xiaomi sports bracelet), bind the sports bracelet to the daily calorie app, and calculate the energy consumed by the daily walking steps and the exercise time of the corresponding exercise (the Xiaomi sports bracelet has been implement this function) 4. Fitness crowd smart device wear distribution4 Healthy eating plan. According to the user's eating habits, give a healthy eating plan (can be customized after payment). According to the user's heart rate and exercise habits, remind the user that they should exercise or take a proper rest, and give a training plan in stages (can be customized after payment) Daily popularize. Daily popularize the nutritional content of healthy food, and call on users to consume more organic food to improve users' dietary sensitivity. 参考链接： NCD-RisC NCD-RisC MobTech 每日互动","categories":[{"name":"HCI","slug":"HCI","permalink":"http://example.com/categories/HCI/"}],"tags":[{"name":"HCI","slug":"HCI","permalink":"http://example.com/tags/HCI/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-11T10:39:21.309Z","updated":"2022-09-11T10:39:21.309Z","comments":true,"path":"2022/09/11/hello-world/","link":"","permalink":"http://example.com/2022/09/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"HCI","slug":"HCI","permalink":"http://example.com/categories/HCI/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"HCI","slug":"HCI","permalink":"http://example.com/tags/HCI/"}]}