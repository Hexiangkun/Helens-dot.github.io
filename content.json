{"meta":{"title":"何相昆","subtitle":"","description":"","author":"hexiangkun","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-09-17T02:39:49.988Z","updated":"2022-09-17T02:39:49.988Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-09-17T02:39:49.989Z","updated":"2022-09-17T02:39:49.989Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-09-17T02:39:49.990Z","updated":"2022-09-17T02:39:49.990Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-09-17T02:39:49.990Z","updated":"2022-09-17T02:39:49.990Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-09-17T02:39:49.990Z","updated":"2022-09-17T02:39:49.990Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-17T02:39:49.992Z","updated":"2022-09-17T02:39:49.992Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-09-17T02:39:49.990Z","updated":"2022-09-17T02:39:49.990Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"webserver","slug":"webserver","date":"2023-04-09T05:15:31.000Z","updated":"2023-04-09T05:43:35.428Z","comments":true,"path":"2023/04/09/webserver/","link":"","permalink":"http://example.com/2023/04/09/webserver/","excerpt":"","text":"一、常见的IO模型 同步阻塞IO用户线程通过系统调用read发起IO读操作。内核等待网卡的数据到来，把网卡数据拷贝到内核空间，再把数据拷贝到用户空间，最后唤醒用户线程。 用户只有在等待read将socket中的数据读取到是，才能继续处理接受的数据。 同步非阻塞IO需要将socket设置为NONBLOCK。这样用户通过系统调用read发起IO请求后可以立即返回。 由于socket是非阻塞的，因此用户线程发起IO请求时立即返回EWOULDBLOCK(EAGAIN) 用户需要不断的调用read，尝试读取socket中数据，直到读取成功，才能继续处理接收到的数据。 IO多路复用线程发起select调用，目的是询问内核数据是否准备完成。等内核把数据准备完成，用户线程发起read调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。 IO多路复用基本原理就是select&#x2F;poll&#x2F;epoll系统调用，单个线程不断轮询select&#x2F;poll&#x2F;epoll所负责的连接，当某个连接有数据到达了，就返回这些读写连接。 异步IO用户线程发起read调用的同时注册一个回调函数，read立即返回。等待内核将数据准备好之后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。 信号驱动IO当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。 二、IO事件处理模式​ 服务器项目程序通常需要处理三类事件：IO事件、信号、定时事件。 Reactor模式​ Reactor是这样一种模式，它要求主线程（IO处理单元）只负责监听文件描述上是否有事件发生，有的话立即将该事件通知工作线程（逻辑单元）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。 ​ 使用同步IO模型（以epoll_wait为例）实现的Reactor模式的工作流程是： ​ 1）主线程往epoll内核事件表中注册socket上的读就绪事件。 ​ 2）主线程调用epoll_wait等待socket上的读就绪事件。 ​ 3）当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。 ​ 4）睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。 ​ 5）主线程调用epoll_wait等待socket可写。 ​ 6）当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 ​ 7）睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。 Proactor模式Proactor模式将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。 ​ 使用异步IO模型（以aio_read和aio_write为例）实现的Proactor模式的工作流程是： ​ 1）主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例） ​ 2）主线程继续处理其他逻辑 ​ 3）当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 ​ 4）应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例） ​ 5）主线程继续处理其他逻辑 ​ 6）当用户缓冲区的数据被写入socket之后，内核向应用程序发送一个信号，以通知应用程序数据已经发送完毕 ​ 7）应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 连接socket上的读写事件是通过aio_read&#x2F;aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。所以主线程的epoll_wait调用仅能用来检测监听socket上的连接请求事件，而不能用来检测连接socket上的读写事件。 模拟Proactor模式使用同步IO方式模拟出Proactor模式的一种方式。其原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。 ​ 使用同步IO模型（以epoll_wait为例）模拟出的Proactor模式的工作流程如下： ​ 1）主线程往epoll内核事件表中注册socket上的读就绪事件 ​ 2）主线程调用epoll_wait等待socket上有数据可读 ​ 3）当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列 ​ 4）睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。 ​ 5）主线程调用epoll_wait等待socket可写 ​ 6）当socekt可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果 三、两种高效的并发模式同步IO&#x2F;异步IO​ 在IO模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种IO事件（是就绪事件还是完成事件），以及该由谁来完成IO读写（是应用程序还是内核）。 ​ 同步IO模型要求用户代码自行执行IO操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区）。 ​ 异步IO机制则由内核来执行IO操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的）。 ​ 同步IO向应用程序通知的是IO就绪事件，异步IO向应用程序通知的是IO完成事件。 半同步&#x2F;半异步模式​ 在并发模式中，“同步”是指程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件（信号、中断等）来驱动。 ​ 半同步&#x2F;半异步模式中，同步线程用于处理客户逻辑；异步线程用于处理IO事件。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。 半同步&#x2F;半反应堆模式（Reactor） 异步线程（主线程）负责监听所有socket上的事件，如果监听socket上由有读事件发生，即有新的连接请求到来，主线程接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送给客户端，主线就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们通过竞争获得任务的接管权。工作线程自己从socket上读取客户请求和往socket写入服务器应答。 半同步&#x2F;半反应堆模式（Proactor） 主线程来完成数据的读写。主线程一般会将应用程序数据、任务类型等信息封装为一个任务对象，然后将其插入请求队列。工作线程从请求队列中取得任务对象后，即可直接处理，无须执行读写操作。 领导者&#x2F;追随者模式领导者&#x2F;追随者模式是多个工作线程轮流获取事件源集合，轮流监听、分发并处理事件的一种模式。在任意时间点，程序都仅有一个领导者线程，它负责监听IO事件。其他线程都是追随者，它们休眠在线程池中等待成为新的领导者。当前领导者如果检测到IO事件，首先从线程池中推选出新的领导者线程，然后处理IO事件。此时，新的领导者等待新的IO事件，而原来的领导者则处理IO事件，二者实现了并发。 四、IO复用的三种方法selectselect把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024. pollpoll使用链表保存文件描述符，其他的跟select没有什么不同。 epollepoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。 ET和LT ET边缘触发模式：在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。 LT边缘触发模式：在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。 EPOLLONESHOT:即使我们使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程（或进程，下同）在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发），此时另外一个线程被唤醒来读取这些新的数据，于是就出现了两个线程同时操作一个 socket的局面。 对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数置该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。但反过来思考，注册了EPOLLONESHOT事件的socket—旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个 socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket。 工作原理 epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。 Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。 eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。 epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。 epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。 三种工作方式对比 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。 select使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。 select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。 select和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。 综上，当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。 五、线程池线程同步机制 RAII RAII全称“Resource Acquisition is Initialization”，即“资源获取即初始化 RAII核心思想：将资源或者状态与对象的生命周期绑定，通过C++的语言机制（构造函数申请资源，析构函数释放资源），实现资源或状态的安全管理，智能指针是RAII的一种。 信号量 一个线程完成了某个动作就通过信号量通知别的线程，别的线程再进行某些动作。 信号量只能取自然数，有两种操作：等待（P）和信号（V）。假设有信号量SV， P，如果SV &gt; 0，将其减1；若SV值为0，则执行挂起操作 V，如果有其他操作因为等待SV而挂起，则唤醒，若没有，则将SV值加1 互斥量（互斥锁） 互斥量，可以保护关键代码段，以确保线程或者进程独占式访问。当进入关键代码段，获得互斥锁将其枷锁；离开关键代码段，唤醒等待该互斥锁的线程。 条件变量 条件变量提供了一种线程间的通知机制，当共享数据达到某个值时，唤醒等待这个共享数据的线程。 线程池中工作线程的状态 一直等待新的任务唤醒 死锁 预防死锁 死锁产生必须满足四个必要条件，互斥条件、不剥夺条件、请求和保持条件、循环等待条件。 破坏互斥条件 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁 解决办法：将临界资源改为可共享使用的资源 缺点：一般情况下，为了系统安全，必须保持这种互斥性，可行性不高 破坏不剥夺条件 不剥夺条件：进程所获得的资源在未使用之前，不能由其他进程强行夺走，只能主动释放 解决办法：申请的资源得不到满足时，立即释放拥有的所有资源；申请的资源被其他进程占用，考虑优先级由操作系统剥夺资源 破坏请求和保持条件 请求和保持条件：进程已经保持至少一个资源，且又提出新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对已有的资源保持不放。 解决办法：进程在运行前，就一次分配所有需要的资源。资源未满足前不能运行，运行后这些资源就一直归它所有。 破坏等待条件 循环等待条件：存在进程资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程所请求。 解决办法：给系统中的资源编号，规定每一个进程必须按编号递增的顺序请求资源，编号相同的资源一次性申请完。 六、日志系统单例模式1、概念：单例模式是指在整个系统生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。 2、实现思路： ​ （1）私有化该类的构造函数和析构函数，以防止外界创建单例类的对象。 ​ （2）拷贝构造函数和赋值构造函数为私有或者删除，目的是禁止外部拷贝和赋值，确保实例的唯一性。 ​ （3）使用类的私有静态指针变量指向该类的唯一实例 ​ （4）通过一个公有静态方法获取该实例 3、实现方式： ​ （1）懒汉模式：在第一次使用该对象时进行初始化 ​ （2）饿汉模式：在程序运行时立即初始化 生产者-消费者模型1、概念： （1）若干个生产者线程，产生任务放入任务队列中，任务队列满了就阻塞，不满就工作。 （2）若干个消费者线程，从任务队列中取出任务，任务队列有有任务就工作，没有任务就阻塞。 （3）生产者和消费者是互斥关系，两者对任务队列的访问互斥 （4）同时消费者和生产者又是一个相互协作与同步的关系，只有生产者生产之后，消费者才能消费。 同步日志日志写入函数与工作线程串行执行，由于涉及到IO操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器的并发能力下降。 异步日志将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。 五、日志类定义 通过静态局部变量的懒汉模式创建日志实例，对其进行初始化生成日志文件后，格式化输出内容，并根据不同的写入方式，完成对应逻辑，写入日志文件。 生成日志文件&amp;&amp;判断写入方式 日志分级与分文件 七、数据库连接池为什么要使用数据库连接池（1）由于服务器需要频繁地访问数据库，即需要频繁创建和断开数据库连接，该过程是一个很耗时的操作，也会对数据库造成安全隐患。 （2）在程序初始化时候，集中创建并管理多个数据库连接，可以保证较快的数据库读写速度，更加安全可靠。 什么是数据库连接池（1）池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化。通俗来说，池是资源的容器，本质上是对资源的复用。 （2）连接池中的资源为一组数据库连接，由程序动态地对池中的连接进行使用、释放。 （3）当系统开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配；当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。 整体概述（1）池可以看作资源的容器，所以有多种实现方法，比如数组、链表、队列等。这里使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。 （2）项目中数据库模块分为两个部分，其一是数据库连接池的定义，其二是利用连接池完成登录和注册的校验功能。具体的，工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还给连接池。 八、定时器原理解析 非活跃，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。 定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。 定时器，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。 定时器容器，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。 具体流程 服务器首先创建定时器容器链表，然后用统一事件源将异常事件，读写事件和信号事件统一处理，根据不同事件的对应逻辑使用定时器。 具体的，浏览器与服务器连接时，创建该连接对应的定时器，并将该定时器添加到定时器容器链表上； 处理异常事件时，执行定时事件，服务器关闭连接，从链表上移除对应定时器； 处理定时信号时，将定时标志设置为true，以便执行定时器处理函数； 处理读&#x2F;写事件时，若某连接上发生读事件或某连接给浏览器发送数据，将对应定时器向后移动，否则，执行定时事件。 九、RAII机制（1）C++语言机制保证，当一个对象创建时会自动调用构造函数，当对象超出作用域时会自动调用析构函数。 （2）所以，我们可以使用类来管理资源，在构造函数中申请分配资源，在析构函数中释放资源。 （3）RAII的核心思想是将资源与对象的生命周期绑定。 十、HTTPHTTP报文 请求报文&#x3D;请求行（request line）、请求头部（header）、空行和请求数据 响应报文&#x3D;状态行+消息报头+空行+响应正文四个部分组成 HTTP处理流程 连接处理：浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，等待工作线程从任务队列中取出一个任务进行处理。 处理报文请求：工作线程取出任务后，调用进程处理函数，通过主、从状态机对请求报文进行解析。 返回响应报文：解析完之后，生成响应报文，返回给浏览器端。 HTTP状态机 从状态机负责读取报文的一行（对其中的\\r\\n修改为\\0\\0），主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。 通过switch-case来体现主状态机的选择，主状态机由CHECK_STATE_REQUESTLINE CHECK_REQUESTHEADER CHECK_REQUEST_CONTENT三个状态组成，用这三个状态来表示：正在解析请求行、请求头、请求消息体 先分析从状态机，从状态机用于处理一行信息（即parse_line函数）。其中包括三个状态：LINE_OPEN, LINE_OK，LINE_BAD，转移过程如下所示： 当从状态机parse_line读到完整的一行，就可以将改行内容递交给process_read函数中的主状态机处理。 主状态机也有三种状态表示正在分析请求行（CHECK_STATE_REQUESTINE）,正在分析头部字段（CHECK_STATE_HEADER），和正在分析内容（CHECK_CONTENT）。 主状态机使用checkstate变量来记录当前的状态。 如果当前的状态是CHECK_STATE_REQUESTLINE，则表示parse_line函数解析出的行是请求行，于是主状态机调用parse_requestline来分析请求行； 如果当前的状态是CHECK_STATE_HEADER，则表示parse_line函数解析出来的是头部字段，于是主状态机调用parse_header来分析头部字段。 如果当前状态是CHECK_CONTENT，则表示parse_line函数解析出来的是消息体，我们调用parse_content来分析消息体（实际上实现时候并没有分析，只是判断是否完整读入） checkstate变量的初始值是CHECK_STATE_REQUESTLINE，调用相应的函数（parse_requestline，parse_header）后更新checkstate实现状态转移。 项目学习前言对于本文项目，主要为了学习web服务器相关知识，不需要全部了解，但是大部分代码都要理清思路，采用以下方式学习： 代码架构：每一个目录负责什么模块（可以结合开源项目的文档，加快对项目的理解） 编译运行：看看有哪些功能 挑出一个功能，细究其代码实现，再考虑其他功能。 添加功能，如何在现有的框架下增加一个功能，比如上传文件，上传博客等等 代码架构 CGImysql：CGI校验程序，负责用户数据与数据库对比 http：实现http协议连接、解析http协议、销毁等 lock：封装互斥锁、信号量、条件变量等 log：日志系统的实现 root：静态网页数据、图片、视频等 threadpool：线程池的实现 timer：定时器的实现 主函数、编译文件等 什么是webserver一个Web Server就是一个服务器软件（程序）。其主要功能是通过HTTP协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的HTTP请求，并对其请求做出HTTP响应，返回给客户端其请求的内容（文件、网页等）或返回一个Error信息。 用户如何与你的Web服务器进行通信通常用户使用Web浏览器与服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则先将你的域名解析成相应的IP地址或者直接根据你的IP地址向对应的Web服务器发送一个HTTP请求。这一过程首先要通过TCP协议的三次握手建立与目标Web服务器的连接，然后HTTP协议生成针对目标Web服务器的HTTP请求报文，通过TCP、IP等协议发送到目标Web服务器上。 Web服务器如何接收客户端发来的HTTP请求报文呢?Web服务器端通过socket监听来自用户的请求。 服务器通过epoll这种I&#x2F;O复用技术（还有select和poll）来实现对监听socket（listenfd）和连接socket（客户请求）的同时监听。注意I&#x2F;O复用虽然可以同时监听多个文件描述符，但是它本身是阻塞的，并且当有多个文件描述符同时就绪的时候，如果不采取额外措施，程序则只能按顺序处理其中就绪的每一个文件描述符，所以为提高效率，我们将在这部分通过线程池来实现并发（多线程并发），为每个就绪的文件描述符分配一个逻辑单元（线程）来处理。 Web服务器如何处理以及响应接收到的HTTP请求报文呢?该项目使用线程池（半同步半反应堆模式）并发处理用户请求，主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等等） 数据库连接池是如何运行的若每次用户请求我们都需要新建一个数据库连接，请求结束后我们释放该数据库连接，当用户请求连接过多时，这种做法过于低效，所以类似线程池的做法，我们构建一个数据库连接池，预先生成一些数据库连接放在那里供用户请求使用。 问题线程池线程的同步机制有哪些？ 信号量、条件变量、互斥量等； 为什么要使用线程池？当你需要限制你应用程序中同时运行的线程数时，线程池非常有用。因为启动一个新线程会带来性能开销，每个线程也会为其堆栈分配一些内存等。为了任务的并发执行，我们可以将这些任务任务传递到线程池，而不是为每个任务动态开启一个新的线程。 线程池中的工作线程是一直等待吗？ 是的，等待新任务的唤醒； 你的线程池工作线程处理完一个任务后的状态是什么？ 如果请求队列为空，则该线程进入线程池中等待；若不为空，则该线程跟其他线程一起进行任务的竞争； 如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？ 该项目是基于IO复用的并发模式。需要注意的是，不是一个客户连接就对应一个线程！当客户连接有事件需要处理的时，epoll会进行事件提醒，将对应的任务加入请求队列，等待工作线程竞争执行。如果速度还是慢，那就只能够增大线程池容量，或者考虑集群分布式的做法。 如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢? 会，因为线程的数量是固定的，如果一个客户请求长时间占用着线程资源，势必会影响到服务器对外的整体响应速度。解决的策略可以是给每一个线程处理任务设定一个时间阈值，当某一个客户请求时间过长，则将其置于任务请求最后，或断开连接。 线程池怎么实现？程序采用c++编写，要自己封装一个简易的线程池类。大致思路是创建固定数目的线程（如跟核数相同），然后类内部维护一个生产者—消费者队列。 提供相应的添加任务（生产者）和执行任务接口（消费者）。按照操作系统书中典型的生产者—消费者模型维护增减队列任务（使用mutex和semaphore）。 mutex用于互斥，保证任意时刻只有一个线程读写队列，semaphore用于同步，保证执行顺序（队列为空时不要读，队列满了不要写）。 定时器为什么要用定时器？——处理定时任务，或者非活跃连接，节省系统资源； 说一下定时器的工作原理？——服务器就为各事件分配一个定时器。该项目使用SIGALRM信号来实现定时器，首先每一个定时事件都处于一个升序链表上，通过alarm()函数周期性触发SIGALRM信号，而后信号回调函数利用管道通知主循环，主循环接收到信号之后对升序链表上的定时器进行处理：若一定时间内无数据交换则关闭连接。 双向链表，删除和添加的时间复杂度说一下？还可以优化吗？添加一般情况下都是O(N)，删除只需要O(1)。从双向链表的方式优化不太现实，可以考虑使用最小堆、或者跳表的数据结构，跳表详见。 最小堆优化？说一下时间复杂度和工作原理最小堆以每个定时器的过期时间进行排序，最小的定时器位于堆顶，当SIGALRM信号触发tick()函数时执行过期定时器清除，如果堆顶的定时器时间过期，则删除，并重新建堆，再判定是否过期，如此循环直到未过期为止。 插入，O(logN)； 删除，O(logN)； 日志说下你的日志系统的运行机制？——初始化服务器时，利用单例模式初始化日志系统，根据配置文件确认是同步还是异步写入的方式。 为什么要异步？和同步的区别是什么？——同步方式写入日志时会产生比较多的系统调用，若是某条日志信息过大，会阻塞日志系统，造成系统瓶颈。异步方式采用生产者-消费者模型，具有较高的并发能力。 压力测试服务器并发量测试过吗？怎么测试的？——测试过，利用webbench，至少满足万余的并发量。 webbench是什么？介绍一下原理——是一款轻量级的网址压力测试工具，可以实现高达3万的并发测试。其原理：Webbench实现的核心原理是：父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。","categories":[],"tags":[]},{"title":"","slug":"计网","date":"2023-04-09T05:13:21.872Z","updated":"2023-04-09T05:34:58.702Z","comments":true,"path":"2023/04/09/计网/","link":"","permalink":"http://example.com/2023/04/09/%E8%AE%A1%E7%BD%91/","excerpt":"","text":"title: 计网date: 2023-04-09 13:13:21tags: socket网络编程的系统调用12345678socket() 创建套接字 bind() 绑定本机端口 connect() 建立连接 （TCP三次握手在调用这个函数时进行）listen() 监听端口accept() 接受连接recv(), read(), recvfrom() 数据接收send(), write(), sendto() 数据发送close(), shutdown() 关闭套接字 close函数-半关闭状态 close并不是一次就能直接关闭，调用close只能将套接字的引用计数减1，可能其他进程还在使用这个套接字，所以并不是直接关闭。只有当套接字的引用计数为0的时候才会终止连接。 使用shutdown可以直接关闭连接。 客户端：调用shutdown(SHUT_WR) 发送⼀个 FIN 包，并且标记该socket为 SEND_SHUTDOWN； 服务端：收到 FIN 包并标记该 socket 为RCV_SHUTDOWN；此时就进入半关闭状态； 同时在TCP协议中，发送关闭请求时，需要对方回复确认请求，否则不能确认，就会造成一个半关闭的状态，这个时候可以接收，不能发送。 各层作用及协议 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。 TCP&#x2F;IP四层模型：应用层、传输层、网络层、数据链路层 物理层 传输数据的单位：比特 数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点） 通道： 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播 双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息 通道复用技术： 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信 数据链路层1.点对点信道 数据单元：帧 三个基本问题： 封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符） 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check） 点对点协议（Point-to-Point Protocol）： 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议 2.广播信道广播通信： 硬件地址（物理地址、MAC 地址） 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧 网络层 IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议） IP 网际协议IP 地址分类： IP 地址 ::= &#123;&lt;网络号&gt;,&lt;主机号&gt;&#125; IP 地址类别 网络号 网络范围 主机号 IP 地址范围 A 类 8bit，第一位固定为 0 0 —— 127 24bit 1.0.0.0 —— 127.255.255.255 B 类 16bit，前两位固定为 10 128.0 —— 191.255 16bit 128.0.0.0 —— 191.255.255.255 C 类 24bit，前三位固定为 110 192.0.0 —— 223.255.255 8bit 192.0.0.0 —— 223.255.255.255 D 类 前四位固定为 1110，后面为多播地址 E 类 前五位固定为 11110，后面保留为今后所用 IP 数据报格式： IP地址、MAC地址作用MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 ARP ARP协议将IP地址转化为MAC地址 同网段工作原理 每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。 当源主机需要将一个数据包要发送到目的主机时，检查自己的 ARP缓存列表中是否存在目标 IP地址对应的MAC地址 如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。 此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址、硬件地址。 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP缓存中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址； 源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 不断网段工作原理 不同网段的主机通信时，主机会封装网关（通常是路由器）的mac地址，然后主机将数据发送给路由器，后续路由进行路由转发，通过arp解析目标地址的mac地址，然后将数据包送达目的地。 ICMP 网际控制报文协议ICMP 报文格式： 应用： PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性 TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量 DNS的工作过程和原理 DNS解析有两种方式：递归查询和迭代查询 递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。 迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果 Ping命令ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议 首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。 然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。 然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。 目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。 内部网关协议 RIP（Routing Information Protocol，路由信息协议） RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。 OSPF（Open Sortest Path First，开放最短路径优先） 详见：https://zhuanlan.zhihu.com/p/41341540 外部网关协议 BGP（Border Gateway Protocol，边界网关协议） IP多播 IGMP（Internet Group Management Protocol，网际组管理协议） 多播路由选择协议 VPN 和 NAT VPN（Virtual Private Network，虚拟专用网） NAT（Network Address Translation，网络地址转换） 路由表包含什么？ 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。 子网掩码（subnet mask）：用来判断 IP 所属网络 下一跳地址&#x2F;接口（Next hop &#x2F; interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。 根据应用和执行的不同，路由表可能含有如下附加信息： 花费（Cost）：就是数据发送过程中通过路径所需要的花费。 路由的服务质量 路由中需要过滤的出&#x2F;入连接列表 网络层分片的原因与具体实现因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。 IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。详见：https://blog.csdn.net/gettogetto/article/details/72851734 运输层协议： TCP（Transmission Control Protocol，传输控制协议） UDP（User Datagram Protocol，用户数据报协议） 端口： 应用程序 FTP TELNET SMTP DNS TFTP HTTP HTTPS SNMP 端口号 21 23 25 53 69 80 443 161 TCP TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。 特征 面向连接 只能点对点（一对一）通信 可靠交互 全双工通信 面向字节流 TCP 如何保证可靠传输 确认和超时重传。 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 数据合理分片和排序 流量控制 TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。滑动窗口协议。 拥塞控制 当网络拥塞时，减少数据的发送。 数据校验 TCP 报文结构 TCP 首部 TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下： URG：紧急比特（urgent），当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。 ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。 PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。 RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。 FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 UDP UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。 特征 无连接 尽最大努力交付 面向报文 没有拥塞控制 支持一对一、一对多、多对一、多对多的交互通信 首部开销小 UDP 报文结构 UDP 首部 TCP&#x2F;UDP 图片来源于：https://github.com/JerryC8080/understand-tcp-udp UDP如何实现可靠传输 因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq&#x2F;ack机制，重传机制和窗口确认机制。 接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。 TCP 与 UDP 的区别 TCP 面向连接，UDP 是无连接的； TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付 TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信 TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题） UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等） TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节 TCP 黏包问题原因TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。 解决 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。 在数据包之间设置边界，如添加特殊符号 \\r\\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \\r\\n，则会误判为消息的边界。 使用更加复杂的应用层协议。 TCP 流量控制概念流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。 TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。 接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。 方法利用可变窗口进行流量控制 TCP 拥塞控制概念拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 方法 慢开始( slow-start ) 拥塞避免( congestion avoidance ) 快重传( fast retransmit ) 快恢复( fast recovery ) TCP的拥塞控制图 发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。 （1）慢启动。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法 （2）拥塞避免。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。 （3）快速重传。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1） （4）快速恢复。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd&#x3D;1，进入慢启动阶段 TCP 传输连接管理 因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png TCP 三次握手建立连接 【TCP 建立连接全过程解释】 客户端发送 SYN &#x3D; 1，seq &#x3D; x 给服务器，说明客户端请求建立连接； 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）； 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）； 服务端收到客户端的 ACK，连接已建立，可以数据传输。 TCP 为什么要进行三次握手？【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。） Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信} 【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。 知乎 . TCP 为什么是三次握手，而不是两次或四次？ 【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 《计算机网络（第 7 版）-谢希仁》 为什么使用三次握手，两次握手可不可以？如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。 举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。 TCP 四次挥手释放连接 【TCP 释放连接全过程解释】 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）； 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）； 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）； 服务端继续发送之前没发完的数据给客户端； 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）； 客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）； 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。 TCP 为什么要进行四次挥手？【问题一】TCP 为什么要进行四次挥手？ &#x2F; 为什么 TCP 建立连接需要三次，而释放连接则需要四次？ 【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。 【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手） 【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。 【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？ 【答案三】 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。 【问题四】TCP怎么保证可靠性 【答案四】 校验和发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 确认应答+序列号TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 TCP 有限状态机 超时重传当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 流量控制TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 拥塞控制当网络拥塞时，减少数据的发送。 TCP 有限状态机图片 服务器端出现大量close_wait原因 close_wait是被动关闭连接是形成的，根据TCP状态机，服务器端收到客户端发送的FIN，TCP协议栈会自动发送ACK，链接进入close_wait状态。但如果服务器端不执行socket的close()操作（即不向客户端发送FIN），状态就不能由close_wait迁移到last_ack，则系统中会存在很多close_wait状态的连接 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收 应用层DNS DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。 域名： 域名 ::= &#123;&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;&#125;，如：blog.huihut.com FTP FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户&#x2F;服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。 TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定 TELNET TELNET 协议是 TCP&#x2F;IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP&#x2F;IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP&#x2F;IP 的封装，TCP&#x2F;IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。 WWW WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问 URL URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address） 标准格式： 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 完整格式： 协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项如：https://github.com/huihut/interview#cc 网页解析的过程和方法 首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。 然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。 如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。 然后是css解析，将css文件解析为样式表对象来渲染DOM树。 在浏览器中输入URL执行全部过程 首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址； 然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接； 接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送） 服务器对客户端发来的http请求进行处理，并返回响应； 释放tcp连接 客户端接收到http响应，将结果渲染展示给用户。 HTTPHTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。 请求方法 方法 意义 OPTIONS 请求一些选项信息，允许客户端查看服务器的性能 GET 请求指定的页面信息，并返回实体主体 HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改 PUT 从客户端向服务器传送的数据取代指定的文档的内容 DELETE 请求服务器删除指定的页面 TRACE 回显服务器收到的请求，主要用于测试或诊断 状态码（Status-Code） 1xx：表示通知信息，如请求收到了或正在进行处理 100 Continue：继续，客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 2xx：表示成功，如接收或知道了 200 OK: 请求成功 3xx：表示重定向，如要完成请求还必须采取进一步的行动 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替 4xx：表示客户的差错，如请求中有错误的语法或不能完成 400 Bad Request: 客户端请求的语法错误，服务器无法理解 401 Unauthorized: 请求要求用户的身份认证 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时 5xx：表示服务器的差错，如服务器失效无法完成请求 500 Internal Server Error: 服务器内部错误，无法完成请求 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求 更多状态码：菜鸟教程 . HTTP状态码 HTTP协议特点 简单快速 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 支持B&#x2F;S及C&#x2F;S模式 灵活 HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态 HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP协议与TCP的区别与联系联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。 区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。 HTTP&#x2F;1.0和HTTP&#x2F;1.1的区别 HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http&#x2F;1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。 HTTP协议和HTTPS协议区别 HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性 HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥 HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书 HTTP协议端口是80，HTTPS协议端口是443 HTTPS缺点 HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加 HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高 HTTPS优点： HTTPS传输数据过程中使用密钥进行加密，所以安全性更高 HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务 Get和Post区别 get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源 get可以保存为书签，可以用缓存来优化，而post不可以 get把请求附在url上，而post把参数附在http包的包体中 浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等 post可以传输二进制编码的信息，get的参数一般只支持ASCII 其他协议 SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途： 用于内部网络或网络服务供应商自动分配 IP 地址给用户 用于内部网络管理员作为对所有电脑作中央管理的手段 SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。","categories":[],"tags":[]},{"title":"排序","slug":"排序","date":"2023-04-09T05:12:01.000Z","updated":"2023-04-09T05:12:59.125Z","comments":true,"path":"2023/04/09/排序/","link":"","permalink":"http://example.com/2023/04/09/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性 冒泡排序 O(n2) O(n2) O(1) 稳定 选择排序 O(n2) O(n2) O(1) 数组不稳定、链表稳定 插入排序 O(n2) O(n2) O(1) 稳定 快速排序 O(n*log2n) O(n2) O(log2n) 不稳定 堆排序 O(n*log2n) O(n*log2n) O(1) 不稳定 归并排序 O(n*log2n) O(n*log2n) O(n) 稳定 希尔排序 O(n*log2n) O(n2) O(1) 不稳定 计数排序 O(n+m) O(n+m) O(n+m) 稳定 桶排序 O(n) O(n) O(m) 稳定 基数排序 O(k*n) O(n2) 稳定 均按从小到大排列 k：代表数值中的 “数位” 个数 n：代表数据规模 m：代表数据的最大值减最小值 冒泡排序 基本思想：通过对待排序的序列从前向后依次比较相邻元素的值，如果发现逆序则交换位置。 ps：逆序——从小到大排序，元素大的在前，元素小的在后就是逆序 代码 1234567891011121314151617181920212223242526272829303132333435//未优化版本void bubblesort(vector&lt;int&gt; &amp;list)&#123; int count = 0; //记录排序趟数 for (int i = 0; i &lt; list.size()-1; i++) &#123; count++; for (int j = 0; j &lt; list.size() - 1; j++) &#123; if (list[j] &gt; list[j + 1]) &#123; swap(list[j], list[j + 1]); &#125; &#125; &#125; cout &lt;&lt; count &lt;&lt; endl;&#125;//优化版本void bubblesort_flag(vector&lt;int&gt;&amp; list)&#123; int count = 0; //记录排序趟数 for (int i = 0; i &lt; list.size() - 1; i++) &#123; bool flag = false; //记录该趟是否交换 count++; for (int j = 0; j &lt; list.size() - 1; j++) &#123; if (list[j] &gt; list[j + 1]) &#123; flag = true; swap(list[j], list[j + 1]); &#125; &#125; if (!flag) &#123; break; &#125; &#125; cout &lt;&lt; count &lt;&lt; endl;&#125; 时间复杂度 如果原数组有序，则遍历一次即可，最好的时间复杂度为O(n) 如果原数组无序，则比较次数是：(n-1)+(n-2)+…..+2+1&#x3D;(n-1)n&#x2F;2&#x3D;O(n2) 稳定性——稳定 选择排序 基本思想：从数组中找到一个最大值（最小值）与序列的末尾（首位）进行交换，再从剩下的序列（除掉序列的末尾或者首位）中找到次最大值（最小值）再进行交换，以此类推，直到完成排序。 代码 123456789101112131415void selectSort(vector&lt;int&gt;&amp; list)&#123; for (int i = 0; i &lt; list.size(); i++) &#123; int min_index = i; //最小值索引 for (int j = i + 1; j &lt; list.size(); j++) &#123; if (list[j] &lt; list[min_index]) &#123;//找到最小值位置 min_index = j; &#125; &#125; if (min_index != i) &#123;//交换首位和最小值 swap(list[min_index], list[i]); &#125; &#125;&#125; 时间复杂度 比较次数和关键字的初始状态无关 总比较次数为(n-1)+(n-2)+…..+2+1&#x3D;(n-1)*n&#x2F;2， 故时间复杂度为O(n2) 稳定性——不稳定 直接插入排序 基本思想：将待排序序列分为两个序列，前面序列保持有序，依次选取后面元素插入到有序序列中。 代码 12345678910111213void insertSort(vector&lt;int&gt;&amp; list)&#123; for (int i = 1; i &lt; list.size(); i++) &#123; int temp = list[i];//待插入元素 int index = i - 1;//初始为前一个元素 while (index &gt;= 0 &amp;&amp; list[index] &gt; temp) &#123; //index合法，前面的元素比待插入元素大 list[index + 1] = list[index];//每当前面的元素比待插入元素大，就向后移动 index--; &#125; list[index + 1] = temp;//找到插入位置 &#125;&#125; 时间复杂度 如果元素有序，每趟只需与前面的有序元素序列最后一个元素进行比较，比较n-1次，元素移动次数为0。时间复杂度为O(n) 如果元素没有序，时间复杂度为O(n2) 稳定性——稳定 希尔排序 基本思想：把序列按下标的一定增量分组，每个分组使用直接插入排序；随着增量的减少，每组包含的关键词越来越多，当增量减少为1的时候，整个序列被分为一组，算法终止 代码 12345678910111213141516void shellSort(vector&lt;int&gt;&amp; list)&#123; int n = list.size(); //进行分组，最开始时增量为数组的一半 for (int gap = n / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; n; i++) &#123; //直接插入排序 int temp = list[i]; int index = i - gap; while (index &gt;= 0 &amp;&amp; list[index] &gt; temp) &#123; list[index + gap] = list[index]; index -= gap; &#125; list[index + gap] = temp; &#125; &#125;&#125; 时间复杂度O(n*log2n) 稳定性——不稳定 归并排序 基本思想 将序列一次次分成子序列，直到子序列长度为1 再将已有序的子序列合并，得到完全有序的序列 代码 123456789101112131415161718192021222324252627282930313233void Merge(vector&lt;int&gt;&amp; list, int left, int mid, int right)&#123; vector&lt;int&gt; temp(list); //临时数组 int i = left;//左边有序序列索引 int j = mid + 1;//右边有序序列索引 int k = left; //执行临时数组当前索引 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (temp[i] &lt;= temp[j]) &#123; list[k++] = temp[i++]; &#125; else &#123; list[k++] = temp[j++]; &#125; &#125; while (i &lt;= mid) &#123; list[k++] = temp[i++]; &#125; while (j &lt;= right) &#123; list[k++] = temp[j++]; &#125;&#125;void MergeSort(vector&lt;int&gt;&amp; list, int left, int right)&#123; if (left &lt; right) &#123; int mid = (left + right)/2; //划分 MergeSort(list, left, mid); //对左侧递归 MergeSort(list, mid + 1, right);//对右侧递归 Merge(list, left, mid, right); //合并 &#125;&#125; 时间复杂度：归并排序是按照分层进行比较的，会分为log2n层；每一层需要比较次数为O(n);故时间复杂度为O(nlog2n) 稳定性——稳定 快速排序 基本思想：任取序列中的一个元素作为中心（枢轴）元素；将所有比枢轴大的元素放到其右边，将所有比枢轴小的元素放到其左边，形成左右两个子序列；再对两个子序列分别进行上述算法进行排序，直到每个子序列只剩下一个元素。 分治法 代码 原始快排 123456789101112131415161718192021222324252627282930int partition(vector&lt;int&gt;&amp; list, int left, int right)&#123; srand(time(nullptr)); int random = rand() % (right - left + 1) + left; swap(list[random], list[left]);//随机划分枢轴 int pivot = list[left]; while (left &lt; right) &#123; while (left&lt;right &amp;&amp; list[right]&gt;pivot) &#123;//从右边找一个比枢轴小的元素 right--; &#125; list[left] = list[right]; while (left &lt; right &amp;&amp; list[left] &lt; pivot) &#123;//从左边找一个比枢轴大的元素 left++; &#125; list[right] = list[left]; &#125; list[left] = pivot;//left和right相等，将枢轴元素赋值 return left;//返回中间元素索引&#125;void quicksort(vector&lt;int&gt;&amp; list,int left, int right)&#123; if (left &lt; right) &#123; int pos = partition(list, left, right); quicksort(list, left, pos - 1); quicksort(list, pos + 1, right); &#125;&#125; 三路快排 12345678910111213141516171819202122232425262728293031void QuickSort(vector&lt;int&gt;&amp; list, int left, int right)&#123; if (left &lt; right) &#123; srand(time(nullptr)); int random = rand() % (right - left + 1) + left; swap(list[random], list[left]); int pivot = list[left]; int l = left; int i = left + 1; int r = right; while (i &lt;= r) &#123; if (list[i] &lt; pivot) &#123; swap(list[i], list[l]); i++; l++; &#125; else if(list[i]==pivot) &#123; i++; &#125; else &#123; swap(list[i], list[r]); r--; &#125; &#125; QuickSort(list, left, l - 1); QuickSort(list, r + 1, right); &#125;&#125; 时间复杂度 最坏情况下：逆序为O(n2) 平均时间复杂度为O(n*log2n) 稳定性——不稳定 堆排序 堆（完全二叉树） 大顶堆：每个节点的值大于或等于其左右孩子节点的值 小顶堆：每个节点的值小于或等于其左右孩子节点的值 基本思想 将待排序序列构建成一个大顶堆，那么，整个序列的最大值就是堆的根节点 将堆顶元素和完全二叉树最后一个元素交换，那么末尾元素就存入了最大值 将剩余n-1个元素重新构建成大顶堆，重复上述操作 代码 12345678910111213141516171819202122232425262728293031323334353637383940void adjustHeap(vector&lt;int&gt;&amp; list, int i, int length)&#123; //非叶子节点 int notleafNodeVal = list[i]; /* k的初始值为当前非叶子节点的左孩子索引 k = 2 * k + 1表示再往左子节点找 */ for (int k = i * 2 + 1; k &lt; length; k = 2 * k + 1) &#123; //如果k+1还在待调整的长度内，且右子树的值大于等于左子树的值 //将k++，此时为当前节点的右孩子 if (k + 1 &lt; length &amp;&amp; list[k] &lt; list[k + 1]) &#123; k++; &#125; //如果孩子节点大于父节点 if (list[k] &gt; notleafNodeVal) &#123; list[i] = list[k];//将当前节点赋值为孩子节点的值 i = k;//将i赋值为孩子节点的索引，再看其孩子节点是否有比它大的 &#125; else &#123; //从左至右，从下至上进行调整，只要上面的不大于，下面的必不大于 break; &#125; &#125; list[i] = notleafNodeVal;&#125;void HeapSort(vector&lt;int&gt;&amp; list)&#123; int n = list.size(); for (int i = n / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(list, i, n); &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; swap(list[i], list[0]); adjustHeap(list, 0, i); &#125;&#125; 时间复杂度 建初始堆，复杂度为O(n) 交换操作次数为n-1次 重建堆的过程时间复杂度近似为O(n*log2n) 堆排序的时间复杂度为O(n*log2n) 稳定性——不稳定 基数排序 基本思想：将整数按位数切割成不同的数字，然后按每个位数分别比较从而得到有序的序列 时间复杂度：O(n) 稳定性——稳定","categories":[{"name":"排序","slug":"排序","permalink":"http://example.com/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"git概述","slug":"git概述","date":"2023-04-09T05:05:58.000Z","updated":"2023-04-09T05:09:15.458Z","comments":true,"path":"2023/04/09/git概述/","link":"","permalink":"http://example.com/2023/04/09/git%E6%A6%82%E8%BF%B0/","excerpt":"","text":"版本控制：版本控制是一种记录若干文件变化，并能查阅历史版本修订情况的系统。 本地版本控制系统：复制整个项目，修改项目名称成为副本。大多数采用数据库赖记录文件的历次更新差异。 集中化版本控制系统：存在一个单一服务器，保存文件修订版本，通过客户端连接服务器，取出最新的文件或者提交更新。 分布式版本控制系统：客户端把整个项目克隆到本地，包括完整的历史记录。 在Git中，当你每次提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。为了效率，如果文件没有被修改，Git不会重新存储该文件，而只保留一个链接指向之前存储的文件。 Git有三种状态：已提交、已修改、已暂存 已修改表示修改了文件，但还没有保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 已提交表示数据已经安全地保存在本地数据库。 这使git项目拥有三个阶段：工作区，暂存区、以及Git目录。 Git工作流程如下： 1、在工作区中修改文件 2、将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 3、提交更新，从暂存区提取文件，将快照永久性的保存到Git目录中。 12345678910111213141516171819git config -l #查看git配置信息git init #创建仓库git status #查看文件处于什么状态git add 文件名 #开始跟踪文件状态git rm --cached 文件名 #删除跟踪文件git commit -m &quot;备注&quot; 文件名 #提交跟踪文件git reflog #查看日志git log #查看详细日志git reset --hard 版本号 #回退历史版本git branch -v #查看分支git branch 分支名 #创建分支git checkout 分支名 #切换分支git merge 分支名 #合并分支git remote -v #查看远程库别名git remote add 别名 链接 #创建远程库别名git remote remove 别名 #删除远程库别名git push 别名 master（分支名） #推送本地库到远程库git pull 别名 master（分支名） #拉取远程库到本地库git clone 远程库链接 #克隆远程库","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"C++基础","slug":"C++基础","date":"2023-04-09T04:44:09.000Z","updated":"2023-04-09T04:45:57.947Z","comments":true,"path":"2023/04/09/C++基础/","link":"","permalink":"http://example.com/2023/04/09/C++%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 语言基础 (C&#x2F;C++)指针和引用的区别 指针是一个新的变量，指向另一个变量的地址，可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变；而引用是一个别名，对引用的操作就是对变量的本身进行操作 指针可以有多级，引用只有一级 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小 指针可以为空，引用不可以。 在函数参数传递的时候，什么时候使用指针，什么时候使用引用？ 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式 堆和栈有什么区别 从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。 堆空间因为会有频繁的分配释放操作，会产生内存碎片 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小 堆快一点还是栈快一点？（字节提前批一面） 栈快一点。 因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。 堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。 new和delete是如何实现的，new 与 malloc的异同处 malloc和free是库函数，new和delete是C++的操作符 new在动态分配内存的时候可以初始化对象，调用其构造函数（malloc&#x2F;构造函数），delete在释放内存时调用对象的析构函数（析构函数&#x2F;free）。 new和malloc都会分配空间，但是new会自己计算需要的空间，malloc需要给定空间大小，而且new只需要对象名。 new和delete可以重载，malloc和free不行。new可以调用malloc来实现，但是malloc不能调用new来实现。 new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。 既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？ https://blog.csdn.net/leikun153/article/details/80612130 malloc&#x2F;free和new&#x2F;delete都是用来申请内存和回收内存的。 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free。 malloc底层实现 malloc小于128K的内存，使用brk分配 将_edata往高地址推（只分配虚拟空间，不对应物理内存（因此没有初始化），第一次读写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后简历虚拟地址和物理地址之间的映射关系） malloc大于128k的内存，使用mmap分配 利用mmap系统调用，从堆和栈的中间分配一块虚拟内存 C和C++的区别包括但不限于： C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。 C和C++内存管理的方法不一样，C使用malloc&#x2F;free，C++除此之外还用new&#x2F;delete C++中还有函数重载和引用等概念，C中没有 delete和delete[]的区别 delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数 用new分配的内存用delete释放，用new[]分配的内存用delete[]释放 C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）包括但不限于： C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。 C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法 C++有指针，Java没有指针，只有引用 JAVA和C++都有构造函数，但是C++有析构函数但是Java没有 C++和python的区别包括但不限于： python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。 python使用缩进来区分不同的代码块，C++使用花括号来区分 C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等 python的库函数比C++的多，调用起来很方便 Struct和class的区别 使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的 struct的继承默认是public继承，而class的继承默认是private继承 class可以用作定义模板参数，而struct不能 define 和const的联系与区别 联系：它们都是定义常量的一种方法。 区别： define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。 define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。 define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。 const可以定义函数而define不可以。 （12） 在C++中const的用法（定义，用途） const修饰类的成员变量时，表示常量不能被修改 const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer） 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 野指针野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。 volatile 关键字 volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。 用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错 register关键字 register关键字请求“编译器”将局部变量存储于寄存器中 static关键字static的意思是静态的，可以用来修饰变量，函数和类成员。 变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。 函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。 类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。 【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。 注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。 const关键字123456789const int a; // 代表一个常整形数int const b; // 代表一个常整形数const int *c;// c是一个指向常整形数的指针(所指向的内存数据不能被修改，但是本身可以修改)int * const d;// d是常指针（指针变量不能被修改，但是它所指向内存空间可以被修改）const int * const e ;// e是一个指向常整形的常指针（指针和它所指向的内存空间，均不能被修改） mutable关键字 在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。 我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。 extern Cextern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 explicit关键字 普通构造函数能够被隐式调用。而explicit构造函数只能被显式调用。 explicit构造函数是用来防止隐式转换的。 指定这个构造器只能被明确的调用&#x2F;使用， 不能作为类型转换操作符被隐含的使用。 final关键字 将类标记为final，意味着继承该类会导致编译错误 允许将虚函数标记为final，意味着子类无法重写该方法。 C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等 C++ STL从广义来讲包括了三类：算法，容器和迭代器。 算法包括排序，复制等常用算法，以及不同容器特定的算法。 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。 迭代器就是在不暴露容器内部结构的情况下对容器的遍历。 allocator内存分配器原理 allocator分配器，其本质上也是调用了malloc函数。 对于大于128B的空间直接就是malloc()和free() 对于小于128B的请求采用了次级分配器；SGI维护一个内存池来处理这些请求，以保证效率。它会将请求的字节数n圆整到8的倍数，比如如果请求的是14B的空间，其实获得的是16B；从这也可以得出SGI一共有16个链表需要维护，每个链表对应一个分配级别，对应的内存块大小分别是：8、16、24、…、128。 Arrayarray即数组，其大小固定，所有元素严格按照内存地址线性排列，array并不维护元素之外的任何多余数据，没有size这个变量 Deque deque是一种能够在头尾两端分别做元素的插入和删除操作的双端队列容器。 deque和vector的区别： deque允许常数项时间对头端元素进行插入和删除操作。vector头部的插入效率低，数据量越大，效率越低 deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并连接起来。 vector访问元素的速度会比deque快。 deque实现原理 从逻辑上看，deque容器是连续空间，但是deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量空间，串接在deque的头端或者尾端。 为了管理这些连续空间，deque容器用数组存储着各个连续空间的首地址。 deque可以随机存取元素（支持索引值直接存取，用[]或者at()方法） Heap 快排和堆排序的比较 堆排序访问数据的方式没有快速排序友好。对于快速排序来说，数据是顺序访问的，对于堆排序来说，数据是跳着访问的。 对于同样的数据，在排序过程中，堆排序算法的数据交换次数多于快速排序。 堆实际上使用数据或者vector表现出来的一颗具有特殊结构的完全二叉树。 大顶堆：每个非叶子节点元素的值均不小于其左右孩子节点。 List list是一个双向链表容器，可以高效地插入和删除元素，支持双向遍历。 list元素节点不要求在一段连续内存中，不能随机存取元素 和其它顺序容器相比，list最大优势在于支持在任意位置插入、删除、移动元素 list主要缺点是不支持元素的随机访问；对内存的使用效率并不高，一方面因为地址不连续，另一方面因为需要额外的保存关联信息 forward_list 顺序容器：支持在任意位置插入和删除元素的容器，单链表 forward_list占用内存空间更小，且插入和删除效率高于list，只能单向遍历 priority_queue priority_queue又称为优先队列，底层用堆来实现。在优先队列中，队首元素一定是优先级最高的一个。 priority_queue的的核心特点在于其严格弱序特性，即priority_queue保证容器第一个元素始终是所有元素最大的 priority_queue的底层容器必须支持随机访问（deque、vector）默认使用vector queue queue是队列容器（容器适配器deque、list），是一种“先进先出”FIFO的容器。（一端插入一端删除） 所谓容器适配器，指它本身只是一个封装层，必须依赖指定的底层容器才能实现具体功能 queue是一种类型的容器的适配器，其是使用特定容器类封装到对象内部，作为其底层容器。（list和deque满足要求） Stack 容器适配器（vector、list、deque）默认使用deque 后进先出，不允许遍历 Map map是标准的关联式容器，一个map是一个键值对序列，即（key，value）。它提供基于key的快速检索能力。 所谓关联容器，是指对所有元素的检索都是通过元素的key进行的，而非元素地址 map中key值是唯一的。map主要用于一对一映射。map内部自建一颗红黑树，这颗树具有对数据自动排序的功能。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入和删除操作上比vector快。 map支持[]操作符，map[key]&#x3D;value Multimap multimap和map的区别：map支持唯一键值，每个键只能出现一次；而multimap相同键可以出现多次。 set set是一个关联式容器，set是一个集合容器，其所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素的插入过程是按排序规则插入，不能指定插入位置。 set采用红黑树的数据结构实现。在插入和删除操作上要比vector快。 set不可以直接存取元素。 不可以直接修改set或者multiset容器中的元素值，因为该容器是自动排列的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。 multiset multiset与set区别：set支持唯一键值，每个元素只能出现一次；而multiset中同一值可以出现多次。 unordered_set unordered_set元素都是不可变的，可以删除和插入，元素不允许重复 unordered_set元素是无序的，不能按照大小排序 unordered_multiset 元素允许重复 unordered_map 关联容器，&lt;key,value&gt;作为元素进行存储 底层数据结构哈希表，不支持排序，使用迭代器进行范围访问时效率低；但是直接访问元素的效率更快 unordered_multimap unordered_multimap是对unordered_map的拓展，唯一区别在于unordered_map允许不同元素的key相同，底层数据结构都是一样的 tuple tuple 叫作元组，它可以把一组类型相同或不同的元素组合到一起，且元素的数量不限 pair 可以看作是把 tuple 的 size 限制为 2 的一个特例 为何map和set的插入和删除效率比其他序列容器高？ 对于关联容器来说，不需要做内存拷贝和内存移动。 因为插入的时候，只需要吧节点的指针指向新的节点就可以了。删除的时候，稍作变换后把指向删除节点的指针指向其他节点。只有指针变换，不存在内存移动。 map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。 set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。 map支持下标操作，set不支持下标操作。 为何map和set每次insert之后，以前保存的iterator不会失效？ iterator相当于指向节点的指针，内存没有变，指向内存的指针就不会失效。（除被删除的元素之外）。 相对于vector来说，每一次插入和删除，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。当使用push_back时，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请更大的内存，复制已有的数据元素到新内存，最后把需要插入的元素放到最后，那么以前内存指针自然就不可用了。 当数据元素增多时，set的插入和搜素速度变化如何？在set中查找使用二分查找。 map和set的区别 map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。 set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。**其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡。 map支持下标操作，set不支持下标操作。 stack stack是堆栈容器，是一种“先进后出”的容器。 stack是简单地装饰deque容器而成为另外的一种容器。 Vector vector和数组的区别 数组：分配的是静态空间，一般分配了就不可以改变。 vector：分配的是动态空间。vector随着元素的加入，空间自动拓展。 vector机制：预留一部分空间，而且预留空间大小是按一定比率增长的，如果空间不够用，重新分配空间，然后将原有元素移动到新空间，同时预留新空间。 vector释放内存 通过swap函数实现内存释放思想。 1vector&lt;int&gt;(vec).swap(vec); vector(vec)临时对象拷贝构造函数拷贝了vec的size和元素，该部分的size和capacity都是7，然后该临时对象和vec交换，vec的size和capacity变成7，临时对象的size为7，capacity为16，然后被析构了。 string的底层实现string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。 string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。 set，map和vector的插入复杂度 set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。 unordered_set,unordered_map的插入复杂度是常数，最坏是O(N). vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝 STL源码中的hash表的实现STL中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。 unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。 解决哈希冲突的方式？ 线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。 二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。 双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。 开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。 建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。 STL中unordered_map和map的区别 unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现&#x3D;&#x3D;操作符。 map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。 STL中vector的实现STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。 在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。 vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。 push_back()函数调用过程中，如果当前vector的长度等于其容量，那么会导致扩容，容量变为之前的两倍。 在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。 push_back()函数是浅拷贝。 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。 C++中vector和list的区别 vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。 list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。 vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+&#x3D;”，“&lt;”等操作符。 list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+&#x3D;”、“&lt;”等 vector::iterator和list::iterator都重载了“++”运算符 总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;如果需要大量的插入和删除，而不关心随机存取，则应使用list。 vector会迭代器失效吗？什么情况下会迭代器失效？https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html 会 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效 当vector在插入的时候，end迭代器肯定会失效 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。 STL中的sort()算法是用什么实现的，stable_sort()呢STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。 https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html 会 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效 当vector在插入的时候，end迭代器肯定会失效 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。 C ++内存管理（热门问题）https://blog.csdn.net/qq_43152052/article/details/98889139 在C++中，内存分成5个区，他们分别是堆、栈、全局&#x2F;静态存储区和常量存储区和代码区。 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 全局&#x2F;静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。字符串常量，之所以称之为常量，因为它可一看作是一个没有命名的字符串且为常量，存放在静态数据区。 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。 代码区，存放程序的二进制代码 关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。 编译链接 预编译：预编译器处理如#define、#include等预编译指令，生成.i或.ii文件 编译：编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化、生成.s文件 汇编：汇编器把汇编码翻译成机器码，生成.o文件 链接：链接器进行地址和空间分配、符号决议、重定位，生成.out文件 内存泄露 概念：程序申请内存后，无法释放已申请的内存空间造成了内存泄露。失去了对该段的控制，因此造成了内存的浪费。 分类： 堆内存泄露 malloc、new从堆中分配的内存 系统资源泄露 主要指程序使用系统分配的资源如socket等没有使用相应的函数释放掉，导致系统内资源的浪费。 没有将基类的析构函数定义为虚函数 当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会调用，子类资源没有正确释放。 介绍面向对象的三大特性，并且举例说明每一个。面向对象的三大特性是：封装，继承和多态。 封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public； 继承使得子类可以复用父类的成员和方法，实现了代码重用； 多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。 计算下面几个类的大小：12345678class A &#123;&#125;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1; A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1; return 0;&#125; 空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。 空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。 1234567class A &#123; virtual Fun()&#123;&#125; &#125;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器); A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器); return 0;&#125; 因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节 1234567class A &#123; static int a; &#125;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1; A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1; return 0;&#125; 静态成员存放在静态存储区，不占用类的大小, 普通成员函数、构造函数、析构函数也不占用类大小 1234567class A &#123; int a; &#125;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4; A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4; return 0;&#125; 1234567class A &#123; static int a; int b; &#125;;;int main()&#123; cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4; A a; cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4; return 0;&#125; 静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节 继承子类的占用空间 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class A&#123;&#125;;class B&#123;&#125;;class C :public A&#123;&#125;;class D :public virtual B&#123;&#125;;class E :public A, public B&#123;&#125;;int main()&#123; A a; B b; C c; D d; E e; cout &lt;&lt; &quot;sizeof(a):&quot; &lt;&lt; sizeof(a) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(b):&quot; &lt;&lt; sizeof(b) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(c):&quot; &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(d):&quot; &lt;&lt; sizeof(d) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(e):&quot; &lt;&lt; sizeof(e) &lt;&lt; endl; return 0;&#125; 输出结果为： 123456sizeof(a):1sizeof(b):1sizeof(c):1sizeof(d):4sizeof(e):1 上面案例定义了一个空类A和B，类C继承了类A，类D继承了虚基类B，类E继承了类A和类B。这些类的对象所占的空间都是1Byte。由此可见，单一继承的空类空间也是 1，多重继承的空类空间还是1，但是虚继承涉及虚表（虚指针），所以sizeof(d)&#x3D;4。 C++中的重载和重写的区别： 重载（overload）是指函数名相同，参数列表（类型不同、数量不同）不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。 重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。 详见：https://blog.csdn.net/weixin_30379911/article/details/99497160 派生类的构造函数与析构函数调用顺序构造函数和析构函数的调用顺序是先构造的后析构，后构造的先析构。 构造函数的调用顺序规则如下所述： 1） 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。 2） 成员类对象构造函数。如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。 3） 派生类构造函数。 而析构函数的调用顺序与构造函数的调用顺序正好相反，将上面3点内容中的顺序反过来用就可以了，即：首先调用派生类的析构函数；其次再调用成员类对象的析构函数；最后调用基类的析构函数。析构函数在下面3种情况时被调用： 1）对象生命周期结束被销毁时（一般类成员的指针变量与引用都不自动调用析构函数）。 2）delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时。 3）对象 i 是对象 o 的成员，o 的析构函数被调用时，对象 i 的析构函数也被调用。 virtual继承虚拟基类是为了解决多重继承而出现的。例如A继承了Y,Z。而Y,Z继承自X，因此A两次出现了类x中的变量和函数，可以将Y,Z定义为虚拟继承。而x则变成了虚拟继承的基类 class X{ }； class Y： public virtual X{ }； class Z： public virtual X{ }； class A ：public Y， public Z{ }； 多态的实现C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。 多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。 虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数. 该实验中有Base父类和Son子类，然后使用了多态，让父类指针指向子类。从结果可以看到： 父类指向子类后，如果调用子类中的虚函数，则调用的是子类虚函数； 如果调用和父类同名的非虚函数，那么还是使用父类的函数 父类不能调用子类自己定义的函数（例如func3），任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法。 C++虚函数表解析 https://www.cnblogs.com/findumars/p/6358207.html?utm_source=itdadao&amp;utm_medium=referral C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。 详见：C++虚函数表剖析 如果多重继承和多继承的话，子类的虚函数表长什么样子？多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：https://blog.csdn.net/qq_36359022/article/details/81870219 实现编译器处理虚函数表应该如何处理编译器处理虚函数的方法是：如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。详见：虚函数的作用及其底层实现机制 基类的析构函数一般写成虚函数的原因首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。 如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。 构造函数为什么一般不定义为虚函数1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等 2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了 构造函数或者析构函数中调用虚函数会怎样在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。 在析构函数中调用虚函数，此时调用的是子类的函数实现方式。 纯虚函数纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承 包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象 使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？ 成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下： 1234567class A&#123;int id;string name;FaceImage face;A(int&amp; inputID,string&amp; inputName,FaceImage&amp; inputFace):id(inputID),name(inputName),face(inputFace)&#123;&#125; // 成员初始化列表&#125;; 因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。另外，有三种情况是必须使用成员初始化列表进行初始化的： 常量成员的初始化，因为常量成员只能初始化不能赋值 引用类型 没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化 详见[C++ 初始化列表]( 静态绑定和动态绑定的介绍C++中的静态绑定和动态绑定 静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。 动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。 而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。 深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。 对象复用的了解，零拷贝的了解对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。 零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。 用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。 介绍C++所有的构造函数C++中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数 默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。 重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。 拷贝构造函数是在发生对象复制的时候调用的。 什么情况下会调用拷贝构造函数（三种情况） 对象以值传递的方式传入函数参数 如 void func(Dog dog)&#123;&#125;; 对象以值传递的方式从函数返回 如 Dog func()&#123; Dog d; return d;&#125; 对象需要通过另外一个对象进行初始化 详见：C++拷贝构造函数详解 结构体内存对齐方式和为什么要进行内存对齐？因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。 对齐规则： 第一个成员在与结构体变量偏移量为0的地址 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 对齐数&#x3D;编译器默认的一个对齐数 与 该成员大小的较小值。 linux 中默认为4 vs 中的默认值为8结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数） 内存泄露的定义，如何检测与避免？动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。 造成内存泄漏的几种原因： 1）类的构造函数和析构函数中new和delete没有配套 2）在释放对象数组时没有使用delete[]，使用了delete 3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露 4）没有正确的清楚嵌套的对象指针 避免方法： malloc&#x2F;free要配套 使用智能指针； 将基类的析构函数设为虚函数； C++的智能指针有哪些C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。 auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。 unique_ptr是一种对资源具有排他性拥有权的智能指针，不能赋值也不能拷贝，保证一个对象只有被一个unique_ptr指向。可以通过移动赋值或者移动拷贝这种方法来重新指定所指对象的所有权。 shared_ptr多个智能指针指向相同的对象，当这个对象所有的智能指针被销毁时就会自动进行回收。拷贝使得对象的引用计数加1，赋值使得原对象引用计数减1（内部使用计数机制进行维护） weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。 调试程序的方法 通过设置断点进行调试 打印log进行调试 打印中间结果进行调试 遇到coredump要怎么调试coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。 使用gdb命令对core文件进行调试 以下例子在Linux上编写一段代码并导致segment fault 并产生core文件 123mkdir coredumpTestvim coredumpTest.cpp 在编辑器内键入 12345678#include&lt;stdio.h&gt;int main()&#123; int i; scanf(&quot;%d&quot;,i);//正确的应该是&amp;i,这里使用i会导致segment fault printf(&quot;%d\\n&quot;,i); return 0;&#125; 编译 12g++ coredumpTest.cpp -g -o coredumpTest 运行 12./coredumpTest 使用gdb调试coredump 12gdb [可执行文件名] [core文件名] inline关键字说一下 和宏定义有什么区别inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。 1、内联函数在编译时展开，而宏在预编译时展开 2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 4、宏不是函数，而inline是函数 5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。 7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。 模板的用法与适用场景 实现原理用template &lt;typename T&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了 编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。 https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html) 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11） 自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作 nullptr：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的 lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125; thread类和mutex类 新的智能指针 unique_ptr和shared_ptr 更多详见：https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279 右值 区分左值和右值：能不能对表达式取地址 移动语义：将内存的所有权从一个对象转移到另外一个对象，高效的移动用来替换效率底下的复制，对象的移动语义需要实现移动构造函数和移动赋值运算符 完美转发：定义一个函数模板，该函数模板可以接收任意类型参数，然后将参数转发给其他目标函数，且保证目标函数接受的参数其类型与传递给模板函数的类型相同。 C++的调用惯例（简单一点C++函数调用的压栈过程）函数的调用过程： 1）从栈空间分配存储空间 2）从实参的存储空间复制值到形参栈空间 3）进行运算 形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。 数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。 当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。 C++的四种cast强制转换四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast static_cast ：用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。 特性与要点： 它没有运行时类型检查，所以是有安全隐患的。 在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。 static_cast不能转换const，volatile等属性 dynamic_cast：用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。dynamic_cast如果不能转换返回NULL。 const_cast：用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。 reinterpret_cast几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。 类型 作用 static_cast 静态类型转换 reinterpreter_cast 重新解释类型转换。 dynamic_cast 子类和父类之间的多态类型转换。 const_cast 去掉const属性转换 一个函数或者可执行文件的生成过程或者编译过程是怎样的预处理，编译，汇编，链接 预处理： 对预处理命令进行替换等预处理操作 编译：代码优化和生成汇编代码 汇编：将汇编代码转化为机器语言 链接：将目标文件彼此链接起来 定义和声明的区别 声明是告诉编译器变量的类型和名字，不会为变量分配空间 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次 typdef和define区别#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查 typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名 被free回收的内存是立即返还给操作系统吗？为什么https://blog.csdn.net/YMY_mine/article/details/81180168 不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。 引用作为函数参数以及返回值的好处对比值传递，引用传参的好处： 1）在函数内部可以对此参数进行修改 2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗） 如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。 用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。 但是有以下的限制： 1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁 2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak 3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 友元函数和友元类https://www.cnblogs.com/zhuguanhao/p/6286145.html 友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。 1）友元函数 有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class A&#123;public: friend void set_show(int x, A &amp;a); //该函数是友元函数的声明private: int data;&#125;;void set_show(int x, A &amp;a) //友元函数定义，为了访问类A中的成员&#123; a.data = x; cout &lt;&lt; a.data &lt;&lt; endl;&#125;int main(void)&#123; class A a; set_show(1, a); return 0;&#125; 一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。 2）友元类 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明 12345678910111213141516171819202122232425262728 #include &lt;iostream&gt;using namespace std;class A&#123;public: friend class C; //这是友元类的声明private: int data;&#125;;class C //友元类定义，为了访问类A中的成员&#123;public: void set_show(int x, A &amp;a) &#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;&#125;;int main(void)&#123; class A a; class C c; c.set_show(1, a); return 0;&#125; 使用友元类时注意： (1) 友元关系不能被继承。 (2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 (3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明 说一下volatile关键字的作用volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。 为什么C++没有实现垃圾回收？ 首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。 垃圾回收会使得C++不适合进行很多底层的操作。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Daliy_Calorie_App","slug":"Daliy-Calorie-App","date":"2022-10-25T12:34:09.000Z","updated":"2023-04-09T04:42:39.298Z","comments":true,"path":"2022/10/25/Daliy-Calorie-App/","link":"","permalink":"http://example.com/2022/10/25/Daliy-Calorie-App/","excerpt":"","text":"Document /* 标签选择器 */ h2 { font-family: \"微软雅黑\"; } p { font-family: \"楷体\"; font-size:20px; } b { font-family: \"楷体\"; font-size:20px; } li{ font-family: \"楷体\"; font-size:20px; } Title: Daliy Calorie App 1. Problem After the third scientific and technological revolution, the quality of life of modern people has improved rapidly, famine has left us, and few people are hungry. In recent years, more and more people have a strong demand for healthy living and body management, so we hope to make such an app to control people's calorie and nutrient intake, and provide corresponding diet plans and Athletic training program. 2. Users So our target demographic is more inclined to young people.Humans who have requirements for weight control and healthy living, or fitness people who need to gain muscle or lose fat. (1). Women: They usually focus on fat reduction, shaping and postpartum repair, and record and test their diet health through fitness apps; (2). Men: They usually lose weight and gain muscle; (3). Teenagers: They make scientific and reasonable sports plans to help themselves grow up healthily; (4). The elderly: They pay more attention to sports injury repair. 3. Task scenario (1). Having meals and want to control intake An obese person reduces his/her calorie intake through diet, so that his/her calorie intake is less than that required for daily basic metabolism. (2). Exercising and want find good plans Anyone who wants to have a better figure can achieve his desired figure by making a reasonable exercise plan. (3). Choosing foods with high protein and low fat Fitness professionals hope to increase their muscle circumference, calculate the daily intake of protein and fat, the minimum intake of carbohydrates, and formulate a reasonable vegetable diet. (4). Rational distribution of aerobic and anaerobic exercise For people who have reduced fat, it is necessary to increase the time of aerobic exercise and reduce the time of anaerobic exercise. For people with muscle enhancement, it is necessary to increase anaerobic exercise time and reduce aerobic exercise time. At the same time, ensure that strength training precedes aerobic exercise. (5). Planning for future exercising Anyone who wants to exercise should plan a future exercise plan to ensure that they are moving in the right direction. 4. Tasks (1). How to Calculate the daily calorie profit and loss daily food calorie intake - basal metabolism - exercise consumption = daily calorie gain and loss The daily food calorie and nutrient intake are captured by the in-app camera, and the category and weight of the food are identified by artificial intelligence. The calculation formula of rough measurement of basal metabolic rate is : Female basal metabolic rate=661+9.6×weight (kg)+1.72×height (cm)-4.7×age Male basal metabolic rate=67+13.73×weight (kg)+5×height (cm)-6.9×age Exercise consumption is calculated by the smart bracelet.Bring a sports bracelet (such as Xiaomi sports bracelet), bind the sports bracelet to the daily calorie app, and calculate the energy consumed by the daily walking steps and the exercise time of the corresponding exercise (the Xiaomi sports bracelet has been implement this function) (2). How to Calculate daily nutrient intake. Authorize the camera, put food on a custom-sized plate (do not stack food), take a photo, identify the category and weight of things through a pre-trained deep learning network, query the nutrients and calories per unit mass of food in the database, and calculate Calorie intake and nutrients. (3). How to Provide nutrition . According to the user's eating habits and fitness purpose, give a healthy eating plan (can be customized after payment). (4). How to provide training programs. According to the user's heart rate and exercise habits, remind the user that they should exercise or take a proper rest, and give a training plan in stages (can be customized after payment) (5). How to Help users achieve a healthy life. Daily popularize the nutritional content of healthy food, and call on users to consume more organic food to improve users' dietary sensitivity. 5. Team role Lin Tong: Detailed design He Xiangkun : Perfect the design & Publish to website","categories":[{"name":"HCI","slug":"HCI","permalink":"http://example.com/categories/HCI/"}],"tags":[{"name":"HCI","slug":"HCI","permalink":"http://example.com/tags/HCI/"}]},{"title":"Daliy_Calorie","slug":"Daliy-Calorie","date":"2022-09-18T02:58:12.000Z","updated":"2023-04-09T04:42:21.997Z","comments":true,"path":"2022/09/18/Daliy-Calorie/","link":"","permalink":"http://example.com/2022/09/18/Daliy-Calorie/","excerpt":"","text":"Document /* 标签选择器 */ h2 { font-family: \"微软雅黑\"; } p { font-family: \"楷体\"; font-size:20px; } b { font-family: \"楷体\"; font-size:20px; } li{ font-family: \"楷体\"; font-size:20px; } Daliy Calorie App 1. Background After the third scientific and technological revolution, the quality of life of modern people has improved rapidly, famine has left us, and few people are hungry. After the third scientific and technological revolution, the quality of life of modern people has improved rapidly, famine has left us, and few people are hungry. 1. Global graph of the number of obese women in 1975-20161 2. Global male obesity graph from 1975-20162 In recent years, more and more people have a strong demand for healthy living and body management, so we hope to make such an app to control people's calorie and nutrient intake, and provide corresponding diet plans and Athletic training program. 2. Application function (1). Calculate the daily calorie profit and loss and daily nutrient intake. (2). Control the user's weight. (3). Provide nutrition and training programs. (4). Help users achieve a healthy life. 3. Calculation formula (1). daily food calorie intake - basal metabolism - exercise consumption = daily calorie gain and loss (2). The daily food calorie and nutrient intake are captured by the in-app camera, and the category and weight of the food are identified by artificial intelligence. (3). The calculation formula of rough measurement of basal metabolic rate is : Female basal metabolic rate=661+9.6×weight (kg)+1.72×height (cm)-4.7×age Male basal metabolic rate=67+13.73×weight (kg)+5×height (cm)-6.9×age (4). Exercise consumption is calculated by the smart bracelet. 4. Target users Our target demographic is more inclined to young people.Humans who have requirements for weight control and healthy living, or fitness people who need to gain muscle or lose fat. 3. Age distribution of fitness people3 5. Team division of labor 5 for demand, 10 for design, 10 for development, 5 for testing, 5 for project, 5 for operation and maintenance, and 3 for overall management. 6. Design tasks and solutions to corresponding problems Calculate the daily food calorie and nutrient intake. Authorize the camera, put food on a custom-sized plate (do not stack food), take a photo, identify the category and weight of things through a pre-trained deep learning network, query the nutrients and calories per unit mass of food in the database, and calculate Calorie intake and nutrients. Calculate the basal metabolism of the human body. Due to the difference of each person's constitution and hormones, it is difficult to accurately measure the basal metabolic rate. We use the calculation formula of the basal metabolic rate: Female basal metabolic rate=661+9.6×weight (kg)+1.72×height (cm)-4.7×age Male basal metabolic rate=67+13.73×weight (kg)+5×height (cm)-6.9×age Calculate the exercise consumption. Bring a sports bracelet (such as Xiaomi sports bracelet), bind the sports bracelet to the daily calorie app, and calculate the energy consumed by the daily walking steps and the exercise time of the corresponding exercise (the Xiaomi sports bracelet has been implement this function) 4. Fitness crowd smart device wear distribution4 Healthy eating plan. According to the user's eating habits, give a healthy eating plan (can be customized after payment). According to the user's heart rate and exercise habits, remind the user that they should exercise or take a proper rest, and give a training plan in stages (can be customized after payment) Daily popularize. Daily popularize the nutritional content of healthy food, and call on users to consume more organic food to improve users' dietary sensitivity. 参考链接： NCD-RisC NCD-RisC MobTech 每日互动","categories":[{"name":"HCI","slug":"HCI","permalink":"http://example.com/categories/HCI/"}],"tags":[{"name":"HCI","slug":"HCI","permalink":"http://example.com/tags/HCI/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-11T10:39:21.309Z","updated":"2022-09-11T10:39:21.309Z","comments":true,"path":"2022/09/11/hello-world/","link":"","permalink":"http://example.com/2022/09/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"排序","slug":"排序","permalink":"http://example.com/categories/%E6%8E%92%E5%BA%8F/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"HCI","slug":"HCI","permalink":"http://example.com/categories/HCI/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"HCI","slug":"HCI","permalink":"http://example.com/tags/HCI/"}]}